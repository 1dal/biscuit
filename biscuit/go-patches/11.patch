diff -r 9599c41ea797 src/runtime/asm_amd64.s
--- a/src/runtime/asm_amd64.s	Sun Dec 14 22:39:32 2014 -0500
+++ b/src/runtime/asm_amd64.s	Mon Dec 22 00:26:27 2014 -0500
@@ -227,7 +227,7 @@
 	// setup tls
 	LEAQ	runtime·tls0(SB), DI
 	PUSHQ	DI
-	CALL	runtime·segsetup(SB)
+	CALL	segsetup(SB)
 
 	MOVQ	8(AX), DI
 	PUSHQ	DI
@@ -285,6 +285,10 @@
 	MOVQ	AX, g_m(CX)
 
 	CALL	intsetup(SB)
+	CALL	timersetup(SB)
+	STI
+flea:
+	JMP	flea
 
 	FINIT
 	MOVQ	CR4, AX
@@ -323,7 +327,6 @@
 	POPQ	AX
 	CALL	runtime·osinit(SB)
 	CALL	runtime·schedinit(SB)
-	CALL	wemadeit(SB)
 
 	// create a new goroutine to start program
 	MOVQ	$runtime·main·f(SB), BP		// entry
@@ -335,6 +338,7 @@
 
 	// start this M
 	CALL	runtime·mstart(SB)
+	CALL	wemadeit(SB)
 
 	MOVL	$0xf1, 0xf1  // crash
 	RET
@@ -388,6 +392,21 @@
 	MOVQ	AX, CR4
 	RET
 
+TEXT rdmsr(SB), NOSPLIT, $0-16
+	MOVQ	reg+0(FP), CX
+	// rdmsr
+	RDMSR
+	MOVL	DX, ret2+12(FP)
+	MOVL	AX, ret1+8(FP)
+	RET
+
+TEXT outb(SB), NOSPLIT, $0-8
+	MOVL	reg+0(FP), DX
+	MOVL	val+4(FP), AX
+	// outb	%al, (%dx)
+	BYTE	$0xee
+	RET
+
 #define IH_NOEC(num, fn)		\
 TEXT fn(SB), NOSPLIT, $0-0;		\
 	PUSHQ	$0;			\
@@ -430,6 +449,8 @@
 IH_NOEC(18,Xmc )
 IH_NOEC(19,Xfp )
 IH_NOEC(20,Xve )
+IH_NOEC(32,Xtimer )
+IH_NOEC(47,Xspur )
 
 TEXT alltraps(SB), NOSPLIT, $0-0
 	MOVQ	SP, AX
diff -r 9599c41ea797 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Sun Dec 14 22:39:32 2014 -0500
+++ b/src/runtime/os_linux.c	Mon Dec 22 00:26:27 2014 -0500
@@ -573,7 +573,7 @@
 
 #pragma textflag NOSPLIT
 uint64
-runtime·segsetup(void *tls0)
+segsetup(void *tls0)
 {
 	uint64 tlsaddr = (uint64)tls0;
 
@@ -601,13 +601,13 @@
 	return (uint64)&pd;
 }
 
+extern void runtime·deray(uint64);
 #pragma textflag NOSPLIT
 void
 marksleep(int8 *msg)
 {
 	pmsg(" ");
 	pmsg(msg);
-	extern void runtime·deray(uint64);
 	runtime·deray(5000000);
 }
 
@@ -749,6 +749,8 @@
 	extern void Xmc (void);
 	extern void Xfp (void);
 	extern void Xve (void);
+	extern void Xtimer(void);
+	extern void Xspur(void);
 
 	int_set(&idt[ 0], (uint64) Xdz , 0);
 	int_set(&idt[ 1], (uint64) Xrz , 0);
@@ -772,6 +774,9 @@
 	int_set(&idt[19], (uint64) Xfp , 0);
 	int_set(&idt[20], (uint64) Xve , 0);
 
+	int_set(&idt[32], (uint64) Xtimer, 0);
+	int_set(&idt[47], (uint64) Xspur, 0);
+
 	pdsetup(&p, (uint64)idt, sizeof(idt) - 1);
 	lidt(&p);
 
@@ -782,10 +787,16 @@
 void
 trap(uint64 *tf)
 {
+	uint64 trapno = *tf;
+
+
+	if (trapno == 32) {
+		runtime·pancake(" TIMER INT ", trapno);
+	}
+
 	pmsg("trap frame at ");
 	pnum((uint64)tf);
 
-	uint64 trapno = *tf;
 	pmsg(" trapno ");
 	pnum(trapno);
 
@@ -813,6 +824,7 @@
 		//	pnum(buf[i]);
 		//	pmsg(" ");
 		//}
+		//pnum(rsp);
 		pmsg(" STACK DUMP      ");
 		const uint64 is = 0x80000000;
 		uint64 *isp = (uint64 *)is - 8;
@@ -913,6 +925,7 @@
 #define PTE_P           (1ULL << 0)
 #define PTE_W           (1ULL << 1)
 #define PTE_U           (1ULL << 2)
+#define PTE_PCD         (1ULL << 4)
 
 #define PTE_ADDR(x)     ((x) & ~0x3ff)
 
@@ -1112,11 +1125,34 @@
 		}
 	}
 	pmsg(" POOF ");
-	pnum((uint64)va);
+	//pnum((uint64)va);
 
 	return 0;
 }
 
+int64
+hack_write(int32 fd, const void *buf, uint64 c)
+{
+	if (fd != 1 && fd != 2)
+		runtime·pancake(" weird fd ", (uint64)fd);
+
+	pmsg(" C> ");
+	pnum(c);
+	pmsg(" <C ");
+	runtime·deray(5000000);
+	int64 ret = (int64)c;
+	byte *p = (byte *)buf;
+	int32 i = 0;
+	while(c--) {
+		runtime·doc(*p++);
+		if ((++i % 20) == 0)
+			runtime·deray(5000000);
+	}
+
+	runtime·deray(5000000);
+	return ret;
+}
+
 #pragma textflag NOSPLIT
 void
 pgtest1(uint64 v)
@@ -1186,3 +1222,123 @@
 
 	pmsg(" mmap passed ");
 }
+
+#pragma textflag NOSPLIT
+uint32
+rlap(volatile uint32 *p, uint32 reg)
+{
+	return p[reg];
+}
+
+#pragma textflag NOSPLIT
+void
+wlap(volatile uint32 *p, uint32 reg, uint32 val)
+{
+	p[reg] = val;
+}
+
+#pragma textflag NOSPLIT
+void
+timersetup(void)
+{
+
+	uint32 *las = (uint32 *)0xfee00000;
+
+	// map lapic memory mapped IO
+	uint64 *pte = pgdir_walk(las, 0);
+	if (pte)
+		runtime·pancake(" lapic mem mapped? ", (uint64)pte);
+	pte = pgdir_walk(las, 1);
+	*pte = (uint64)las | PTE_W | PTE_P | PTE_PCD;
+
+#define LVTIMER     (0x320/4)
+#define DCREG       (0x3e0/4)
+#define DIVONE      0xb
+#define ICREG       (0x380/4)
+
+	// timer: periodic, int 32
+	wlap(las, LVTIMER, 1 << 17 | 32);
+	// divide by
+	wlap(las, DCREG, DIVONE);
+	// initial count
+	wlap(las, ICREG, 10000000);
+
+#define LVCMCI      (0x2f0/4)
+#define LVINT0      (0x350/4)
+#define LVINT1      (0x360/4)
+#define LVERROR     (0x370/4)
+#define LVPERF      (0x340/4)
+#define LVTHERMAL   (0x330/4)
+
+#define MASKSHIFT   16
+
+	// mask cmci, lint[01], error, perf counters, and thermal sensor
+	wlap(las, LVCMCI,    1 << MASKSHIFT);
+	//wlap(las, LVINT0,    1 << MASKSHIFT);
+	wlap(las, LVINT1,    1 << MASKSHIFT);
+	wlap(las, LVERROR,   1 << MASKSHIFT);
+	wlap(las, LVPERF,    1 << MASKSHIFT);
+	wlap(las, LVTHERMAL, 1 << MASKSHIFT);
+
+#define IA32_APIC_BASE   0x1b
+	extern uint64 rdmsr(uint64);
+	uint64 reg = rdmsr(IA32_APIC_BASE);
+	if (!(reg & (1 << 11)))
+		runtime·pancake(" lapic disabled? ", reg);
+	if (reg >> 12 != 0xfee00)
+		runtime·pancake(" weird base addr? ", reg >> 12);
+
+#define LVSPUR     (0xf0/4)
+	uint32 lreg = rlap(las, LVSPUR);
+	if (lreg & (1 << 12))
+		pmsg(" EOI broadcast surpression ");
+	if (lreg & (1 << 9))
+		pmsg(" focus processor checking ");
+	if (lreg & (1 << 8))
+		pmsg(" apic enabled ");
+	else
+		pmsg(" apic disabled ");
+
+	wlap(las, LVSPUR, 1 << 8 | 47);
+	//wlap(las, LVSPUR, lreg & ~(1 << 8));
+	lreg = rlap(las, LVSPUR);
+	if (lreg & (1 << 8))
+		pmsg(" apic enabled ");
+	else
+		pmsg(" apic disabled ");
+
+//#define EOIREG      (0xb0/4)
+//	wlap(las, EOIREG, 0);
+
+//#define ESREG       (0x280/4)
+//	wlap(las, ESREG, 0);
+//	wlap(las, ESREG, 0);
+
+//#define ICRHIREG      (0x310/4)
+//#define ICRLOREG      (0x300/4)
+//	wlap(las, ICRHIREG, 0);
+//	wlap(las, ICRLOREG, 0x00080000 | 0x00000500 | 0x00008000);
+//	while (rlap(las, ICRLOREG) & 0x00001000);
+//	pmsg (" loopy ");
+
+//#define TPREG       (0x80/4)
+//	wlap(las, TPREG, 0);
+
+	// 8259a - mask all ints
+	extern void outb(uint32, uint32);
+	outb(0x20 + 1, 0xff);
+	outb(0xa0 + 1, 0xff);
+}
+
+#pragma textflag NOSPLIT
+int32
+hack_clone(int32 flags, void *stack, M *mp, G *gp, void (*fn)(void))
+{
+	USED(mp);
+	USED(gp);
+	USED(flags);
+	USED(stack);
+	runtime·pancake(" in crone ", (uint64)fn);
+
+	return 0;
+}
diff -r 9599c41ea797 src/runtime/sys_linux_amd64.s
--- a/src/runtime/sys_linux_amd64.s	Sun Dec 14 22:39:32 2014 -0500
+++ b/src/runtime/sys_linux_amd64.s	Mon Dec 22 00:26:27 2014 -0500
@@ -38,6 +38,12 @@
 	RET
 
 TEXT runtime·write(SB),NOSPLIT,$0-28
+	MOVQ	runtime·hackmode(SB), DI
+	TESTQ	DI, DI
+	JZ	write_skip
+	JMP	hack_write(SB)
+	RET
+write_skip:
 	MOVQ	fd+0(FP), DI
 	MOVQ	p+8(FP), SI
 	MOVL	n+16(FP), DX
@@ -179,6 +185,11 @@
 	RET
 
 TEXT runtime·rtsigprocmask(SB),NOSPLIT,$0-28
+	MOVQ	runtime·hackmode(SB), DI
+	TESTQ	DI, DI
+	JZ	spm_skip
+	RET
+spm_skip:
 	MOVL	sig+0(FP), DI
 	MOVQ	new+8(FP), SI
 	MOVQ	old+16(FP), DX
@@ -191,6 +202,12 @@
 	RET
 
 TEXT runtime·rt_sigaction(SB),NOSPLIT,$0-36
+	MOVQ	runtime·hackmode(SB), DI
+	TESTQ	DI, DI
+	JZ	sa_skip
+	MOVL	$0, ret+32(FP)
+	RET
+sa_skip:
 	MOVQ	sig+0(FP), DI
 	MOVQ	new+8(FP), SI
 	MOVQ	old+16(FP), DX
@@ -300,6 +317,12 @@
 
 // int32 clone(int32 flags, void *stack, M *mp, G *gp, void (*fn)(void));
 TEXT runtime·clone(SB),NOSPLIT,$0
+	MOVQ	runtime·hackmode(SB), DI
+	TESTQ	DI, DI
+	JZ	clone_skip
+	JMP	hack_clone(SB)
+	RET
+clone_skip:
 	MOVL	flags+8(SP), DI
 	MOVQ	stack+16(SP), SI
 
@@ -346,6 +369,11 @@
 	JMP	-3(PC)	// keep exiting
 
 TEXT runtime·sigaltstack(SB),NOSPLIT,$-8
+	MOVQ	runtime·hackmode(SB), DI
+	TESTQ	DI, DI
+	JZ	sas_skip
+	RET
+sas_skip:
 	MOVQ	new+8(SP), DI
 	MOVQ	old+16(SP), SI
 	MOVQ	$131, AX
