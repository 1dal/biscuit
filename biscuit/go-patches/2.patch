changeset:   21874:7fbeea021a7d
parent:      21811:ffe33f1f1f17
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Mon Dec 01 19:25:36 2014 -0500
summary:     clear bss, enable paging

diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/asm_386.s
--- a/src/runtime/asm_386.s	Tue Nov 25 15:41:33 2014 +1100
+++ b/src/runtime/asm_386.s	Mon Dec 01 19:25:36 2014 -0500
@@ -115,6 +115,43 @@
 DATA	runtime·main·f+0(SB)/4,$runtime·main(SB)
 GLOBL	runtime·main·f(SB),RODATA,$4
 
+//DATA	runtime·pgd+0(SB)/4,$0
+GLOBL	runtime·pgd(SB),NOPTR,$4
+
+TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
+	MOVL	$0x7c00, SP
+
+	CALL	runtime·pginit(SB)
+
+	PUSHL	$0x20
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+fleabag:
+	JMP	fleabag
+
+TEXT runtime·lcr3(SB),NOSPLIT,$0-4
+	MOVL	pgt+0(FP), AX
+	MOVL	AX, CR3
+	RET
+
+TEXT runtime·rcr3(SB),NOSPLIT,$0-4
+	MOVL	CR3, AX
+	MOVL	AX, ret+0(FP)
+	RET
+
+TEXT runtime·enable_paging(SB),NOSPLIT,$0-0
+	MOVL	CR0, AX
+	ORL	$(1 << 31), AX	// PAGING ENABLE
+	MOVL	AX, CR0
+	RET
+
 TEXT runtime·breakpoint(SB),NOSPLIT,$0-0
 	INT $3
 	RET
diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/hackstuff.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/runtime/hackstuff.h	Mon Dec 01 19:25:36 2014 -0500
@@ -0,0 +1,50 @@
+#ifndef _HACKSTUFF_H
+#define _HACKSTUFF_H
+
+struct Elf {
+	uint32 e_magic;
+#define ELF_MAGIC 0x464C457FU	/* "\x7FELF" in little endian */
+	uint8 e_elf[12];
+	uint16 e_type;
+	uint16 e_machine;
+	uint32 e_version;
+	uint32 e_entry;
+	uint32 e_phoff;
+	uint32 e_shoff;
+	uint32 e_flags;
+	uint16 e_ehsize;
+	uint16 e_phentsize;
+	uint16 e_phnum;
+	uint16 e_shentsize;
+	uint16 e_shnum;
+	uint16 e_shstrndx;
+};
+
+struct Proghdr {
+	uint32 p_type;
+	uint32 p_offset;
+	uint32 p_va;
+	uint32 p_pa;
+	uint32 p_filesz;
+	uint32 p_memsz;
+	uint32 p_flags;
+	uint32 p_align;
+};
+
+#define PGSIZE          (1UL << 12)
+#define PGOFFMASK       (PGSIZE - 1)
+#define PGMASK          (~PGOFFMASK)
+
+#define ROUNDDOWN(x, y) ((x) & ~((y) - 1))
+#define ROUNDUP(x, y)   (((x) + ((y) - 1)) & ~((y) - 1))
+
+#define PDX(x)          (((x) >> 22) & 0x3ff)
+#define PTX(x)          (((x) >> 12) & 0x3ff)
+
+#define PTE_P           (1 << 0)
+#define PTE_W           (1 << 1)
+#define PTE_U           (1 << 2)
+
+#define PTE_ADDR(x)     ((x) & ~0x3ff)
+
+#endif
diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/os_linux_386.c
--- a/src/runtime/os_linux_386.c	Tue Nov 25 15:41:33 2014 +1100
+++ b/src/runtime/os_linux_386.c	Mon Dec 01 19:25:36 2014 -0500
@@ -36,3 +36,197 @@
 		}
 	}
 }
+
+#pragma textflag NOSPLIT
+static void
+putch(int8 x, int8 y, int8 c)
+{
+        int16 *cons = (int16 *)0xb8000;
+        cons[y*80 + x] = 0x07 << 8 | c;
+}
+
+#pragma textflag NOSPLIT
+void
+runtime·doc(int64 mark)
+{
+        static int8 x;
+        static int8 y;
+
+        putch(x++, y, mark & 0xff);
+        //putch(x++, y, ' ');
+        if (x >= 79) {
+                x = 0;
+                y++;
+        }
+
+	if (y >= 29)
+		y = 0;
+}
+
+#pragma textflag NOSPLIT
+static void
+pnum(int64 n)
+{
+	int32 nn = (int32)n;
+	int32 i;
+
+	//for (i = 60; i >= 0; i -= 4) {
+	for (i = 28; i >= 0; i -= 4) {
+		int32 cn = (nn >> i) & 0xf;
+
+		if (cn >= 0 && cn <= 9)
+			runtime·doc('0' + cn);
+		else
+			runtime·doc('A' + cn - 10);
+	}
+}
+
+#pragma textflag NOSPLIT
+static void
+pmsg(int8 *msg)
+{
+	while (*msg)
+		runtime·doc(*msg++);
+}
+
+
+#pragma textflag NOSPLIT
+static void
+pancake(int8 *msg, int64 addr)
+{
+	runtime·doc(' ');
+
+	pmsg(msg);
+
+	runtime·doc(' ');
+	pnum(addr);
+	pmsg(" PANCAKE");
+	while (1);
+}
+
+#include "hackstuff.h"
+
+#pragma textflag NOSPLIT
+static uint32
+getpg(void)
+{
+	static uint32 last;
+
+	extern uint8 runtime·end[];
+	if (!last)
+		last = ROUNDUP((uint32)runtime·end, PGSIZE);
+
+	uint32 ret = last;
+	last += PGSIZE;
+
+	if (ret & PGOFFMASK)
+		pancake("not aligned", ret);
+
+	if (ret >= 0xc0000000 || ret < 0x01000000)
+		pancake("weird addr", ret);
+
+	int32 i;
+	for (i = 0; i < PGSIZE/4; i++)
+		((uint32 *)ret)[i] = 0;
+
+	return ret;
+}
+
+#pragma textflag NOSPLIT
+static void
+mapone(uint32 *pgd, uint32 va, uint32 pa)
+{
+	if (pa & PGOFFMASK)
+		pancake("pa not aligned", pa);
+
+	uint32 pde = pgd[PDX(va)];
+
+	if (!(pde & PTE_P)) {
+		pde = getpg() | PTE_P | PTE_W;
+		pgd[PDX(va)] = pde;
+	}
+
+	uint32 *pgt = (uint32 *)PTE_ADDR(pde);
+
+	if (pgt[PTX(va)] & PTE_P)
+		pancake("already mapped?", PTE_ADDR(pgt[PTX(va)]));
+
+	pgt[PTX(va)] = pa | PTE_P | PTE_W;
+}
+
+#pragma textflag NOSPLIT
+static void
+bootmap(uint32 *pgd, uint32 va, uint32 pa, uint32 sz)
+{
+	int32 i;
+	for (i = 0; i < sz; i += PGSIZE)
+		mapone(pgd, va + i, pa + i);
+}
+
+#pragma textflag NOSPLIT
+static void
+addsegs(struct Elf *e, uint32 *pgd)
+{
+	struct Proghdr *ph = (struct Proghdr *)((int8 *)e + e->e_phoff);
+	struct Proghdr *eph = ph + e->e_phnum;
+
+	for (; ph < eph; ph++) {
+		if (ph->p_type != 1) // PT_LOAD
+			continue;
+
+		bootmap(pgd, ph->p_pa, ph->p_pa, ph->p_memsz);
+	}
+}
+
+#pragma textflag NOSPLIT
+static void
+bsshack(void)
+{
+#define SAVE(x)	((uint32 *)(((uint32 *)0x7e00)[x]))
+	uint32 *start = SAVE(0);
+	uint32 *end = SAVE(1);
+#undef SAVE
+	while (start < end)
+		*start++ = 0;
+}
+
+extern uint32 *runtime·pgd;
+extern void runtime·lcr3(uint32);
+extern uint32 runtime·rcr3(void);
+extern void runtime·enable_paging(void);
+
+#pragma textflag NOSPLIT
+void
+runtime·pginit(void)
+{
+	int32 i;
+
+	// XXX the bootloader and this code assume there is at least ~130 MB of
+	// physical memory. should parse the e820 map.
+	bsshack();
+
+	runtime·pgd = (uint32 *)getpg();
+	if ((uint32)runtime·pgd & PGOFFMASK)
+		pancake("pgd not aligned?", (uint32)runtime·pgd);
+
+	for (i = 0; i < 1024; i++)
+		runtime·pgd[i] = 0;
+
+	// sweet hack -- header is still at physical address 0x10000
+	struct Elf *e = (struct Elf *)0x10000;
+	addsegs(e, runtime·pgd);
+	// give us VGA so we can print
+	mapone(runtime·pgd, 0xb8000, 0xb8000);
+	// and our stack
+	mapone(runtime·pgd, 0x7000, 0x7000);
+
+	runtime·lcr3((uint32)runtime·pgd);
+	pmsg("loaded cr3 ");
+	runtime·enable_paging();
+	pmsg("paging enabled ");
+	uint32 cr3 = runtime·rcr3();
+	pmsg("cr3 is ");
+	pnum(cr3);
+	//*(byte *)0 = 1;
+	//pmsg("wut");
+}
diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/rt0_linux_386.s
--- a/src/runtime/rt0_linux_386.s	Tue Nov 25 15:41:33 2014 +1100
+++ b/src/runtime/rt0_linux_386.s	Mon Dec 01 19:25:36 2014 -0500
@@ -12,6 +12,7 @@
 	CALL	runtime·linux_setup_vdso(SB)
 	CALL	main(SB)
 	INT	$3
+	CALL	_rt0_hack(SB)
 
 TEXT main(SB),NOSPLIT,$0
 	JMP	runtime·rt0_go(SB)
@@ -23,3 +24,6 @@
 DATA	runtime·_vdso(SB)/4, $_fallback_vdso(SB)
 GLOBL	runtime·_vdso(SB), NOPTR, $4
 
+TEXT _rt0_hack(SB),NOSPLIT,$0
+	CALL	runtime·rt0_go_hack(SB)
+	INT	$3

changeset:   21875:c2306e1c8f08
tag:         tip
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Tue Dec 02 21:38:36 2014 -0500
summary:     use amd64 instead

diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/asm_386.s
--- a/src/runtime/asm_386.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/asm_386.s	Tue Dec 02 21:38:36 2014 -0500
@@ -115,43 +115,6 @@
 DATA	runtime·main·f+0(SB)/4,$runtime·main(SB)
 GLOBL	runtime·main·f(SB),RODATA,$4
 
-//DATA	runtime·pgd+0(SB)/4,$0
-GLOBL	runtime·pgd(SB),NOPTR,$4
-
-TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
-	MOVL	$0x7c00, SP
-
-	CALL	runtime·pginit(SB)
-
-	PUSHL	$0x20
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-fleabag:
-	JMP	fleabag
-
-TEXT runtime·lcr3(SB),NOSPLIT,$0-4
-	MOVL	pgt+0(FP), AX
-	MOVL	AX, CR3
-	RET
-
-TEXT runtime·rcr3(SB),NOSPLIT,$0-4
-	MOVL	CR3, AX
-	MOVL	AX, ret+0(FP)
-	RET
-
-TEXT runtime·enable_paging(SB),NOSPLIT,$0-0
-	MOVL	CR0, AX
-	ORL	$(1 << 31), AX	// PAGING ENABLE
-	MOVL	AX, CR0
-	RET
-
 TEXT runtime·breakpoint(SB),NOSPLIT,$0-0
 	INT $3
 	RET
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/asm_amd64.s
--- a/src/runtime/asm_amd64.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/asm_amd64.s	Tue Dec 02 21:38:36 2014 -0500
@@ -119,6 +119,26 @@
 	// No per-thread init.
 	RET
 
+TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
+	//MOVL	$0x7c00, SP
+
+	//CALL	runtime·pginit(SB)
+
+	PUSHQ	$0x20
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0xdeadbeef
+	PUSHQ	$0
+	CALL	runtime·pancake(SB)
+	INT	$3
+
 /*
  *  go-routine
  */
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/os_linux.c	Tue Dec 02 21:38:36 2014 -0500
@@ -340,3 +340,69 @@
 {
 	return runtime·sigtab[sig].name;
 }
+
+#pragma textflag NOSPLIT
+static void
+putch(int8 x, int8 y, int8 c)
+{
+        int16 *cons = (int16 *)0xb8000;
+        cons[y*80 + x] = 0x07 << 8 | c;
+}
+
+#pragma textflag NOSPLIT
+void
+runtime·doc(int64 mark)
+{
+        static int8 x;
+        static int8 y;
+
+        putch(x++, y, mark & 0xff);
+        //putch(x++, y, ' ');
+        if (x >= 79) {
+                x = 0;
+                y++;
+        }
+
+	if (y >= 29)
+		y = 0;
+}
+
+#pragma textflag NOSPLIT
+static void
+pnum(uint64 n)
+{
+	uint64 nn = (uint64)n;
+	int64 i;
+
+	for (i = 60; i >= 0; i -= 4) {
+		uint64 cn = (nn >> i) & 0xf;
+
+		if (cn >= 0 && cn <= 9)
+			runtime·doc('0' + cn);
+		else
+			runtime·doc('A' + cn - 10);
+	}
+}
+
+#pragma textflag NOSPLIT
+static void
+pmsg(int8 *msg)
+{
+	if (msg)
+		while (*msg)
+			runtime·doc(*msg++);
+}
+
+#pragma textflag NOSPLIT
+void
+runtime·pancake(int8 *msg, int64 addr)
+{
+	runtime·doc(' ');
+
+	pmsg(msg);
+
+	runtime·doc(' ');
+	pnum(addr);
+	pmsg(" PANCAKE");
+	while (1);
+}
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/os_linux_386.c
--- a/src/runtime/os_linux_386.c	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/os_linux_386.c	Tue Dec 02 21:38:36 2014 -0500
@@ -36,197 +36,3 @@
 		}
 	}
 }
-
-#pragma textflag NOSPLIT
-static void
-putch(int8 x, int8 y, int8 c)
-{
-        int16 *cons = (int16 *)0xb8000;
-        cons[y*80 + x] = 0x07 << 8 | c;
-}
-
-#pragma textflag NOSPLIT
-void
-runtime·doc(int64 mark)
-{
-        static int8 x;
-        static int8 y;
-
-        putch(x++, y, mark & 0xff);
-        //putch(x++, y, ' ');
-        if (x >= 79) {
-                x = 0;
-                y++;
-        }
-
-	if (y >= 29)
-		y = 0;
-}
-
-#pragma textflag NOSPLIT
-static void
-pnum(int64 n)
-{
-	int32 nn = (int32)n;
-	int32 i;
-
-	//for (i = 60; i >= 0; i -= 4) {
-	for (i = 28; i >= 0; i -= 4) {
-		int32 cn = (nn >> i) & 0xf;
-
-		if (cn >= 0 && cn <= 9)
-			runtime·doc('0' + cn);
-		else
-			runtime·doc('A' + cn - 10);
-	}
-}
-
-#pragma textflag NOSPLIT
-static void
-pmsg(int8 *msg)
-{
-	while (*msg)
-		runtime·doc(*msg++);
-}
-
-
-#pragma textflag NOSPLIT
-static void
-pancake(int8 *msg, int64 addr)
-{
-	runtime·doc(' ');
-
-	pmsg(msg);
-
-	runtime·doc(' ');
-	pnum(addr);
-	pmsg(" PANCAKE");
-	while (1);
-}
-
-#include "hackstuff.h"
-
-#pragma textflag NOSPLIT
-static uint32
-getpg(void)
-{
-	static uint32 last;
-
-	extern uint8 runtime·end[];
-	if (!last)
-		last = ROUNDUP((uint32)runtime·end, PGSIZE);
-
-	uint32 ret = last;
-	last += PGSIZE;
-
-	if (ret & PGOFFMASK)
-		pancake("not aligned", ret);
-
-	if (ret >= 0xc0000000 || ret < 0x01000000)
-		pancake("weird addr", ret);
-
-	int32 i;
-	for (i = 0; i < PGSIZE/4; i++)
-		((uint32 *)ret)[i] = 0;
-
-	return ret;
-}
-
-#pragma textflag NOSPLIT
-static void
-mapone(uint32 *pgd, uint32 va, uint32 pa)
-{
-	if (pa & PGOFFMASK)
-		pancake("pa not aligned", pa);
-
-	uint32 pde = pgd[PDX(va)];
-
-	if (!(pde & PTE_P)) {
-		pde = getpg() | PTE_P | PTE_W;
-		pgd[PDX(va)] = pde;
-	}
-
-	uint32 *pgt = (uint32 *)PTE_ADDR(pde);
-
-	if (pgt[PTX(va)] & PTE_P)
-		pancake("already mapped?", PTE_ADDR(pgt[PTX(va)]));
-
-	pgt[PTX(va)] = pa | PTE_P | PTE_W;
-}
-
-#pragma textflag NOSPLIT
-static void
-bootmap(uint32 *pgd, uint32 va, uint32 pa, uint32 sz)
-{
-	int32 i;
-	for (i = 0; i < sz; i += PGSIZE)
-		mapone(pgd, va + i, pa + i);
-}
-
-#pragma textflag NOSPLIT
-static void
-addsegs(struct Elf *e, uint32 *pgd)
-{
-	struct Proghdr *ph = (struct Proghdr *)((int8 *)e + e->e_phoff);
-	struct Proghdr *eph = ph + e->e_phnum;
-
-	for (; ph < eph; ph++) {
-		if (ph->p_type != 1) // PT_LOAD
-			continue;
-
-		bootmap(pgd, ph->p_pa, ph->p_pa, ph->p_memsz);
-	}
-}
-
-#pragma textflag NOSPLIT
-static void
-bsshack(void)
-{
-#define SAVE(x)	((uint32 *)(((uint32 *)0x7e00)[x]))
-	uint32 *start = SAVE(0);
-	uint32 *end = SAVE(1);
-#undef SAVE
-	while (start < end)
-		*start++ = 0;
-}
-
-extern uint32 *runtime·pgd;
-extern void runtime·lcr3(uint32);
-extern uint32 runtime·rcr3(void);
-extern void runtime·enable_paging(void);
-
-#pragma textflag NOSPLIT
-void
-runtime·pginit(void)
-{
-	int32 i;
-
-	// XXX the bootloader and this code assume there is at least ~130 MB of
-	// physical memory. should parse the e820 map.
-	bsshack();
-
-	runtime·pgd = (uint32 *)getpg();
-	if ((uint32)runtime·pgd & PGOFFMASK)
-		pancake("pgd not aligned?", (uint32)runtime·pgd);
-
-	for (i = 0; i < 1024; i++)
-		runtime·pgd[i] = 0;
-
-	// sweet hack -- header is still at physical address 0x10000
-	struct Elf *e = (struct Elf *)0x10000;
-	addsegs(e, runtime·pgd);
-	// give us VGA so we can print
-	mapone(runtime·pgd, 0xb8000, 0xb8000);
-	// and our stack
-	mapone(runtime·pgd, 0x7000, 0x7000);
-
-	runtime·lcr3((uint32)runtime·pgd);
-	pmsg("loaded cr3 ");
-	runtime·enable_paging();
-	pmsg("paging enabled ");
-	uint32 cr3 = runtime·rcr3();
-	pmsg("cr3 is ");
-	pnum(cr3);
-	//*(byte *)0 = 1;
-	//pmsg("wut");
-}
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/rt0_linux_386.s
--- a/src/runtime/rt0_linux_386.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/rt0_linux_386.s	Tue Dec 02 21:38:36 2014 -0500
@@ -12,7 +12,6 @@
 	CALL	runtime·linux_setup_vdso(SB)
 	CALL	main(SB)
 	INT	$3
-	CALL	_rt0_hack(SB)
 
 TEXT main(SB),NOSPLIT,$0
 	JMP	runtime·rt0_go(SB)
@@ -23,7 +22,3 @@
 
 DATA	runtime·_vdso(SB)/4, $_fallback_vdso(SB)
 GLOBL	runtime·_vdso(SB), NOPTR, $4
-
-TEXT _rt0_hack(SB),NOSPLIT,$0
-	CALL	runtime·rt0_go_hack(SB)
-	INT	$3
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/rt0_linux_amd64.s
--- a/src/runtime/rt0_linux_amd64.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/rt0_linux_amd64.s	Tue Dec 02 21:38:36 2014 -0500
@@ -8,8 +8,14 @@
 	LEAQ	8(SP), SI // argv
 	MOVQ	0(SP), DI // argc
 	MOVQ	$main(SB), AX
-	JMP	AX
+	CALL	AX
+	CALL	_rt0_hack(SB)
+	INT	$3
 
 TEXT main(SB),NOSPLIT,$-8
 	MOVQ	$runtime·rt0_go(SB), AX
 	JMP	AX
+
+TEXT _rt0_hack(SB),NOSPLIT,$0
+	CALL	runtime·rt0_go_hack(SB)
+	INT	$3

