changeset:   21874:7fbeea021a7d
parent:      21811:ffe33f1f1f17
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Mon Dec 01 19:25:36 2014 -0500
summary:     clear bss, enable paging

diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/asm_386.s
--- a/src/runtime/asm_386.s	Tue Nov 25 15:41:33 2014 +1100
+++ b/src/runtime/asm_386.s	Mon Dec 01 19:25:36 2014 -0500
@@ -115,6 +115,43 @@
 DATA	runtime·main·f+0(SB)/4,$runtime·main(SB)
 GLOBL	runtime·main·f(SB),RODATA,$4
 
+//DATA	runtime·pgd+0(SB)/4,$0
+GLOBL	runtime·pgd(SB),NOPTR,$4
+
+TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
+	MOVL	$0x7c00, SP
+
+	CALL	runtime·pginit(SB)
+
+	PUSHL	$0x20
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+fleabag:
+	JMP	fleabag
+
+TEXT runtime·lcr3(SB),NOSPLIT,$0-4
+	MOVL	pgt+0(FP), AX
+	MOVL	AX, CR3
+	RET
+
+TEXT runtime·rcr3(SB),NOSPLIT,$0-4
+	MOVL	CR3, AX
+	MOVL	AX, ret+0(FP)
+	RET
+
+TEXT runtime·enable_paging(SB),NOSPLIT,$0-0
+	MOVL	CR0, AX
+	ORL	$(1 << 31), AX	// PAGING ENABLE
+	MOVL	AX, CR0
+	RET
+
 TEXT runtime·breakpoint(SB),NOSPLIT,$0-0
 	INT $3
 	RET
diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/hackstuff.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/runtime/hackstuff.h	Mon Dec 01 19:25:36 2014 -0500
@@ -0,0 +1,50 @@
+#ifndef _HACKSTUFF_H
+#define _HACKSTUFF_H
+
+struct Elf {
+	uint32 e_magic;
+#define ELF_MAGIC 0x464C457FU	/* "\x7FELF" in little endian */
+	uint8 e_elf[12];
+	uint16 e_type;
+	uint16 e_machine;
+	uint32 e_version;
+	uint32 e_entry;
+	uint32 e_phoff;
+	uint32 e_shoff;
+	uint32 e_flags;
+	uint16 e_ehsize;
+	uint16 e_phentsize;
+	uint16 e_phnum;
+	uint16 e_shentsize;
+	uint16 e_shnum;
+	uint16 e_shstrndx;
+};
+
+struct Proghdr {
+	uint32 p_type;
+	uint32 p_offset;
+	uint32 p_va;
+	uint32 p_pa;
+	uint32 p_filesz;
+	uint32 p_memsz;
+	uint32 p_flags;
+	uint32 p_align;
+};
+
+#define PGSIZE          (1UL << 12)
+#define PGOFFMASK       (PGSIZE - 1)
+#define PGMASK          (~PGOFFMASK)
+
+#define ROUNDDOWN(x, y) ((x) & ~((y) - 1))
+#define ROUNDUP(x, y)   (((x) + ((y) - 1)) & ~((y) - 1))
+
+#define PDX(x)          (((x) >> 22) & 0x3ff)
+#define PTX(x)          (((x) >> 12) & 0x3ff)
+
+#define PTE_P           (1 << 0)
+#define PTE_W           (1 << 1)
+#define PTE_U           (1 << 2)
+
+#define PTE_ADDR(x)     ((x) & ~0x3ff)
+
+#endif
diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/os_linux_386.c
--- a/src/runtime/os_linux_386.c	Tue Nov 25 15:41:33 2014 +1100
+++ b/src/runtime/os_linux_386.c	Mon Dec 01 19:25:36 2014 -0500
@@ -36,3 +36,197 @@
 		}
 	}
 }
+
+#pragma textflag NOSPLIT
+static void
+putch(int8 x, int8 y, int8 c)
+{
+        int16 *cons = (int16 *)0xb8000;
+        cons[y*80 + x] = 0x07 << 8 | c;
+}
+
+#pragma textflag NOSPLIT
+void
+runtime·doc(int64 mark)
+{
+        static int8 x;
+        static int8 y;
+
+        putch(x++, y, mark & 0xff);
+        //putch(x++, y, ' ');
+        if (x >= 79) {
+                x = 0;
+                y++;
+        }
+
+	if (y >= 29)
+		y = 0;
+}
+
+#pragma textflag NOSPLIT
+static void
+pnum(int64 n)
+{
+	int32 nn = (int32)n;
+	int32 i;
+
+	//for (i = 60; i >= 0; i -= 4) {
+	for (i = 28; i >= 0; i -= 4) {
+		int32 cn = (nn >> i) & 0xf;
+
+		if (cn >= 0 && cn <= 9)
+			runtime·doc('0' + cn);
+		else
+			runtime·doc('A' + cn - 10);
+	}
+}
+
+#pragma textflag NOSPLIT
+static void
+pmsg(int8 *msg)
+{
+	while (*msg)
+		runtime·doc(*msg++);
+}
+
+
+#pragma textflag NOSPLIT
+static void
+pancake(int8 *msg, int64 addr)
+{
+	runtime·doc(' ');
+
+	pmsg(msg);
+
+	runtime·doc(' ');
+	pnum(addr);
+	pmsg(" PANCAKE");
+	while (1);
+}
+
+#include "hackstuff.h"
+
+#pragma textflag NOSPLIT
+static uint32
+getpg(void)
+{
+	static uint32 last;
+
+	extern uint8 runtime·end[];
+	if (!last)
+		last = ROUNDUP((uint32)runtime·end, PGSIZE);
+
+	uint32 ret = last;
+	last += PGSIZE;
+
+	if (ret & PGOFFMASK)
+		pancake("not aligned", ret);
+
+	if (ret >= 0xc0000000 || ret < 0x01000000)
+		pancake("weird addr", ret);
+
+	int32 i;
+	for (i = 0; i < PGSIZE/4; i++)
+		((uint32 *)ret)[i] = 0;
+
+	return ret;
+}
+
+#pragma textflag NOSPLIT
+static void
+mapone(uint32 *pgd, uint32 va, uint32 pa)
+{
+	if (pa & PGOFFMASK)
+		pancake("pa not aligned", pa);
+
+	uint32 pde = pgd[PDX(va)];
+
+	if (!(pde & PTE_P)) {
+		pde = getpg() | PTE_P | PTE_W;
+		pgd[PDX(va)] = pde;
+	}
+
+	uint32 *pgt = (uint32 *)PTE_ADDR(pde);
+
+	if (pgt[PTX(va)] & PTE_P)
+		pancake("already mapped?", PTE_ADDR(pgt[PTX(va)]));
+
+	pgt[PTX(va)] = pa | PTE_P | PTE_W;
+}
+
+#pragma textflag NOSPLIT
+static void
+bootmap(uint32 *pgd, uint32 va, uint32 pa, uint32 sz)
+{
+	int32 i;
+	for (i = 0; i < sz; i += PGSIZE)
+		mapone(pgd, va + i, pa + i);
+}
+
+#pragma textflag NOSPLIT
+static void
+addsegs(struct Elf *e, uint32 *pgd)
+{
+	struct Proghdr *ph = (struct Proghdr *)((int8 *)e + e->e_phoff);
+	struct Proghdr *eph = ph + e->e_phnum;
+
+	for (; ph < eph; ph++) {
+		if (ph->p_type != 1) // PT_LOAD
+			continue;
+
+		bootmap(pgd, ph->p_pa, ph->p_pa, ph->p_memsz);
+	}
+}
+
+#pragma textflag NOSPLIT
+static void
+bsshack(void)
+{
+#define SAVE(x)	((uint32 *)(((uint32 *)0x7e00)[x]))
+	uint32 *start = SAVE(0);
+	uint32 *end = SAVE(1);
+#undef SAVE
+	while (start < end)
+		*start++ = 0;
+}
+
+extern uint32 *runtime·pgd;
+extern void runtime·lcr3(uint32);
+extern uint32 runtime·rcr3(void);
+extern void runtime·enable_paging(void);
+
+#pragma textflag NOSPLIT
+void
+runtime·pginit(void)
+{
+	int32 i;
+
+	// XXX the bootloader and this code assume there is at least ~130 MB of
+	// physical memory. should parse the e820 map.
+	bsshack();
+
+	runtime·pgd = (uint32 *)getpg();
+	if ((uint32)runtime·pgd & PGOFFMASK)
+		pancake("pgd not aligned?", (uint32)runtime·pgd);
+
+	for (i = 0; i < 1024; i++)
+		runtime·pgd[i] = 0;
+
+	// sweet hack -- header is still at physical address 0x10000
+	struct Elf *e = (struct Elf *)0x10000;
+	addsegs(e, runtime·pgd);
+	// give us VGA so we can print
+	mapone(runtime·pgd, 0xb8000, 0xb8000);
+	// and our stack
+	mapone(runtime·pgd, 0x7000, 0x7000);
+
+	runtime·lcr3((uint32)runtime·pgd);
+	pmsg("loaded cr3 ");
+	runtime·enable_paging();
+	pmsg("paging enabled ");
+	uint32 cr3 = runtime·rcr3();
+	pmsg("cr3 is ");
+	pnum(cr3);
+	//*(byte *)0 = 1;
+	//pmsg("wut");
+}
diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/rt0_linux_386.s
--- a/src/runtime/rt0_linux_386.s	Tue Nov 25 15:41:33 2014 +1100
+++ b/src/runtime/rt0_linux_386.s	Mon Dec 01 19:25:36 2014 -0500
@@ -12,6 +12,7 @@
 	CALL	runtime·linux_setup_vdso(SB)
 	CALL	main(SB)
 	INT	$3
+	CALL	_rt0_hack(SB)
 
 TEXT main(SB),NOSPLIT,$0
 	JMP	runtime·rt0_go(SB)
@@ -23,3 +24,6 @@
 DATA	runtime·_vdso(SB)/4, $_fallback_vdso(SB)
 GLOBL	runtime·_vdso(SB), NOPTR, $4
 
+TEXT _rt0_hack(SB),NOSPLIT,$0
+	CALL	runtime·rt0_go_hack(SB)
+	INT	$3

changeset:   21875:c2306e1c8f08
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Tue Dec 02 21:38:36 2014 -0500
summary:     use amd64 instead

diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/asm_386.s
--- a/src/runtime/asm_386.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/asm_386.s	Tue Dec 02 21:38:36 2014 -0500
@@ -115,43 +115,6 @@
 DATA	runtime·main·f+0(SB)/4,$runtime·main(SB)
 GLOBL	runtime·main·f(SB),RODATA,$4
 
-//DATA	runtime·pgd+0(SB)/4,$0
-GLOBL	runtime·pgd(SB),NOPTR,$4
-
-TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
-	MOVL	$0x7c00, SP
-
-	CALL	runtime·pginit(SB)
-
-	PUSHL	$0x20
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-fleabag:
-	JMP	fleabag
-
-TEXT runtime·lcr3(SB),NOSPLIT,$0-4
-	MOVL	pgt+0(FP), AX
-	MOVL	AX, CR3
-	RET
-
-TEXT runtime·rcr3(SB),NOSPLIT,$0-4
-	MOVL	CR3, AX
-	MOVL	AX, ret+0(FP)
-	RET
-
-TEXT runtime·enable_paging(SB),NOSPLIT,$0-0
-	MOVL	CR0, AX
-	ORL	$(1 << 31), AX	// PAGING ENABLE
-	MOVL	AX, CR0
-	RET
-
 TEXT runtime·breakpoint(SB),NOSPLIT,$0-0
 	INT $3
 	RET
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/asm_amd64.s
--- a/src/runtime/asm_amd64.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/asm_amd64.s	Tue Dec 02 21:38:36 2014 -0500
@@ -119,6 +119,26 @@
 	// No per-thread init.
 	RET
 
+TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
+	//MOVL	$0x7c00, SP
+
+	//CALL	runtime·pginit(SB)
+
+	PUSHQ	$0x20
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0xdeadbeef
+	PUSHQ	$0
+	CALL	runtime·pancake(SB)
+	INT	$3
+
 /*
  *  go-routine
  */
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/os_linux.c	Tue Dec 02 21:38:36 2014 -0500
@@ -340,3 +340,69 @@
 {
 	return runtime·sigtab[sig].name;
 }
+
+#pragma textflag NOSPLIT
+static void
+putch(int8 x, int8 y, int8 c)
+{
+        int16 *cons = (int16 *)0xb8000;
+        cons[y*80 + x] = 0x07 << 8 | c;
+}
+
+#pragma textflag NOSPLIT
+void
+runtime·doc(int64 mark)
+{
+        static int8 x;
+        static int8 y;
+
+        putch(x++, y, mark & 0xff);
+        //putch(x++, y, ' ');
+        if (x >= 79) {
+                x = 0;
+                y++;
+        }
+
+	if (y >= 29)
+		y = 0;
+}
+
+#pragma textflag NOSPLIT
+static void
+pnum(uint64 n)
+{
+	uint64 nn = (uint64)n;
+	int64 i;
+
+	for (i = 60; i >= 0; i -= 4) {
+		uint64 cn = (nn >> i) & 0xf;
+
+		if (cn >= 0 && cn <= 9)
+			runtime·doc('0' + cn);
+		else
+			runtime·doc('A' + cn - 10);
+	}
+}
+
+#pragma textflag NOSPLIT
+static void
+pmsg(int8 *msg)
+{
+	if (msg)
+		while (*msg)
+			runtime·doc(*msg++);
+}
+
+#pragma textflag NOSPLIT
+void
+runtime·pancake(int8 *msg, int64 addr)
+{
+	runtime·doc(' ');
+
+	pmsg(msg);
+
+	runtime·doc(' ');
+	pnum(addr);
+	pmsg(" PANCAKE");
+	while (1);
+}
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/os_linux_386.c
--- a/src/runtime/os_linux_386.c	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/os_linux_386.c	Tue Dec 02 21:38:36 2014 -0500
@@ -36,197 +36,3 @@
 		}
 	}
 }
-
-#pragma textflag NOSPLIT
-static void
-putch(int8 x, int8 y, int8 c)
-{
-        int16 *cons = (int16 *)0xb8000;
-        cons[y*80 + x] = 0x07 << 8 | c;
-}
-
-#pragma textflag NOSPLIT
-void
-runtime·doc(int64 mark)
-{
-        static int8 x;
-        static int8 y;
-
-        putch(x++, y, mark & 0xff);
-        //putch(x++, y, ' ');
-        if (x >= 79) {
-                x = 0;
-                y++;
-        }
-
-	if (y >= 29)
-		y = 0;
-}
-
-#pragma textflag NOSPLIT
-static void
-pnum(int64 n)
-{
-	int32 nn = (int32)n;
-	int32 i;
-
-	//for (i = 60; i >= 0; i -= 4) {
-	for (i = 28; i >= 0; i -= 4) {
-		int32 cn = (nn >> i) & 0xf;
-
-		if (cn >= 0 && cn <= 9)
-			runtime·doc('0' + cn);
-		else
-			runtime·doc('A' + cn - 10);
-	}
-}
-
-#pragma textflag NOSPLIT
-static void
-pmsg(int8 *msg)
-{
-	while (*msg)
-		runtime·doc(*msg++);
-}
-
-
-#pragma textflag NOSPLIT
-static void
-pancake(int8 *msg, int64 addr)
-{
-	runtime·doc(' ');
-
-	pmsg(msg);
-
-	runtime·doc(' ');
-	pnum(addr);
-	pmsg(" PANCAKE");
-	while (1);
-}
-
-#include "hackstuff.h"
-
-#pragma textflag NOSPLIT
-static uint32
-getpg(void)
-{
-	static uint32 last;
-
-	extern uint8 runtime·end[];
-	if (!last)
-		last = ROUNDUP((uint32)runtime·end, PGSIZE);
-
-	uint32 ret = last;
-	last += PGSIZE;
-
-	if (ret & PGOFFMASK)
-		pancake("not aligned", ret);
-
-	if (ret >= 0xc0000000 || ret < 0x01000000)
-		pancake("weird addr", ret);
-
-	int32 i;
-	for (i = 0; i < PGSIZE/4; i++)
-		((uint32 *)ret)[i] = 0;
-
-	return ret;
-}
-
-#pragma textflag NOSPLIT
-static void
-mapone(uint32 *pgd, uint32 va, uint32 pa)
-{
-	if (pa & PGOFFMASK)
-		pancake("pa not aligned", pa);
-
-	uint32 pde = pgd[PDX(va)];
-
-	if (!(pde & PTE_P)) {
-		pde = getpg() | PTE_P | PTE_W;
-		pgd[PDX(va)] = pde;
-	}
-
-	uint32 *pgt = (uint32 *)PTE_ADDR(pde);
-
-	if (pgt[PTX(va)] & PTE_P)
-		pancake("already mapped?", PTE_ADDR(pgt[PTX(va)]));
-
-	pgt[PTX(va)] = pa | PTE_P | PTE_W;
-}
-
-#pragma textflag NOSPLIT
-static void
-bootmap(uint32 *pgd, uint32 va, uint32 pa, uint32 sz)
-{
-	int32 i;
-	for (i = 0; i < sz; i += PGSIZE)
-		mapone(pgd, va + i, pa + i);
-}
-
-#pragma textflag NOSPLIT
-static void
-addsegs(struct Elf *e, uint32 *pgd)
-{
-	struct Proghdr *ph = (struct Proghdr *)((int8 *)e + e->e_phoff);
-	struct Proghdr *eph = ph + e->e_phnum;
-
-	for (; ph < eph; ph++) {
-		if (ph->p_type != 1) // PT_LOAD
-			continue;
-
-		bootmap(pgd, ph->p_pa, ph->p_pa, ph->p_memsz);
-	}
-}
-
-#pragma textflag NOSPLIT
-static void
-bsshack(void)
-{
-#define SAVE(x)	((uint32 *)(((uint32 *)0x7e00)[x]))
-	uint32 *start = SAVE(0);
-	uint32 *end = SAVE(1);
-#undef SAVE
-	while (start < end)
-		*start++ = 0;
-}
-
-extern uint32 *runtime·pgd;
-extern void runtime·lcr3(uint32);
-extern uint32 runtime·rcr3(void);
-extern void runtime·enable_paging(void);
-
-#pragma textflag NOSPLIT
-void
-runtime·pginit(void)
-{
-	int32 i;
-
-	// XXX the bootloader and this code assume there is at least ~130 MB of
-	// physical memory. should parse the e820 map.
-	bsshack();
-
-	runtime·pgd = (uint32 *)getpg();
-	if ((uint32)runtime·pgd & PGOFFMASK)
-		pancake("pgd not aligned?", (uint32)runtime·pgd);
-
-	for (i = 0; i < 1024; i++)
-		runtime·pgd[i] = 0;
-
-	// sweet hack -- header is still at physical address 0x10000
-	struct Elf *e = (struct Elf *)0x10000;
-	addsegs(e, runtime·pgd);
-	// give us VGA so we can print
-	mapone(runtime·pgd, 0xb8000, 0xb8000);
-	// and our stack
-	mapone(runtime·pgd, 0x7000, 0x7000);
-
-	runtime·lcr3((uint32)runtime·pgd);
-	pmsg("loaded cr3 ");
-	runtime·enable_paging();
-	pmsg("paging enabled ");
-	uint32 cr3 = runtime·rcr3();
-	pmsg("cr3 is ");
-	pnum(cr3);
-	//*(byte *)0 = 1;
-	//pmsg("wut");
-}
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/rt0_linux_386.s
--- a/src/runtime/rt0_linux_386.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/rt0_linux_386.s	Tue Dec 02 21:38:36 2014 -0500
@@ -12,7 +12,6 @@
 	CALL	runtime·linux_setup_vdso(SB)
 	CALL	main(SB)
 	INT	$3
-	CALL	_rt0_hack(SB)
 
 TEXT main(SB),NOSPLIT,$0
 	JMP	runtime·rt0_go(SB)
@@ -23,7 +22,3 @@
 
 DATA	runtime·_vdso(SB)/4, $_fallback_vdso(SB)
 GLOBL	runtime·_vdso(SB), NOPTR, $4
-
-TEXT _rt0_hack(SB),NOSPLIT,$0
-	CALL	runtime·rt0_go_hack(SB)
-	INT	$3
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/rt0_linux_amd64.s
--- a/src/runtime/rt0_linux_amd64.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/rt0_linux_amd64.s	Tue Dec 02 21:38:36 2014 -0500
@@ -8,8 +8,14 @@
 	LEAQ	8(SP), SI // argv
 	MOVQ	0(SP), DI // argc
 	MOVQ	$main(SB), AX
-	JMP	AX
+	CALL	AX
+	CALL	_rt0_hack(SB)
+	INT	$3
 
 TEXT main(SB),NOSPLIT,$-8
 	MOVQ	$runtime·rt0_go(SB), AX
 	JMP	AX
+
+TEXT _rt0_hack(SB),NOSPLIT,$0
+	CALL	runtime·rt0_go_hack(SB)
+	INT	$3

changeset:   21876:3a1f8ad32b44
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Mon Dec 08 11:02:40 2014 -0500
summary:     checkpoint segmentation setup

diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/asm_amd64.s
--- a/src/runtime/asm_amd64.s	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/asm_amd64.s	Mon Dec 08 11:02:40 2014 -0500
@@ -119,10 +119,173 @@
 	// No per-thread init.
 	RET
 
+TEXT retardtown(SB),NOSPLIT,$0
+	MOVQ	(SP), AX
+	PUSHQ	$(3 << 3)
+	PUSHQ	AX
+	// lret
+	BYTE	$0xcb
+
 TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
-	//MOVL	$0x7c00, SP
 
-	//CALL	runtime·pginit(SB)
+//	CMPQ	DI, $0
+//	JEQ	duder
+//dud:
+//	JMP dud
+//duder:
+
+	// save page table and first free address from bootloader.
+	MOVL	DI, runtime·pgtbl(SB)
+	MOVL	SI, runtime·first_free(SB)
+
+	ANDQ	$~15, SP
+
+	// create istack out of the given (operating system) stack.
+	// _cgo_init may update stackguard.
+	MOVQ	$runtime·g0(SB), DI
+	LEAQ	(-64*1024+104)(SP), BX
+	MOVQ	BX, g_stackguard0(DI)
+	MOVQ	BX, g_stackguard1(DI)
+	MOVQ	BX, (g_stack+stack_lo)(DI)
+	MOVQ	SP, (g_stack+stack_hi)(DI)
+
+	// find out information about the processor we're on
+	MOVQ	$0, AX
+	CPUID
+	CMPQ	AX, $0
+	JE	h_nocpuinfo
+	MOVQ	$1, AX
+	CPUID
+	MOVL	CX, runtime·cpuid_ecx(SB)
+	MOVL	DX, runtime·cpuid_edx(SB)
+h_nocpuinfo:
+
+	PUSHQ	$0x20
+	CALL	runtime·doc(SB)
+	POPQ	AX
+
+	PUSHQ	$0x39
+	CALL	runtime·doc(SB)
+	CALL	runtime·doc(SB)
+	POPQ	AX
+
+	// if there is an _cgo_init, call it.
+	//MOVQ	_cgo_init(SB), AX
+	//TESTQ	AX, AX
+	//JZ	needtls
+	//// g0 already in DI
+	//MOVQ	DI, CX	// Win64 uses CX for first parameter
+	//MOVQ	$setg_gcc<>(SB), SI
+	//CALL	AX
+
+	//// update stackguard after _cgo_init
+	//MOVQ	$runtime·g0(SB), CX
+	//MOVQ	(g_stack+stack_lo)(CX), AX
+	//ADDQ	$const_StackGuard, AX
+	//MOVQ	AX, g_stackguard0(CX)
+	//MOVQ	AX, g_stackguard1(CX)
+
+	//CMPL	runtime·iswindows(SB), $0
+	//JEQ ok
+h_needtls:
+
+	//// skip TLS setup on Plan 9
+	//CMPL	runtime·isplan9(SB), $1
+	//JEQ ok
+	//// skip TLS setup on Solaris
+	//CMPL	runtime·issolaris(SB), $1
+	//JEQ ok
+
+//	CMPQ	AX, $0
+//	JEQ	duder
+//dud:
+//	JMP dud
+//duder:
+
+	// setup tls
+	LEAQ	runtime·tls0(SB), DI
+	PUSHQ	DI
+	CALL	runtime·segsetup(SB)
+
+	MOVQ	8(AX), DI
+	PUSHQ	DI
+	MOVQ	(AX), DI
+	PUSHQ	DI
+	// lgdt (%rsp)
+	BYTE	$0x0f
+	BYTE	$0x01
+	BYTE	$0x14
+	BYTE	$0x24
+	POPQ	AX
+	POPQ	AX
+
+	MOVQ	$(2 << 3), AX
+	PUSHQ	AX
+	POPQ	FS
+
+	//CALL retardtown(SB)
+
+	// store through it, to make sure it works
+	get_tls(BX)
+	MOVQ	$0x123, g(BX)
+	MOVQ	runtime·tls0(SB), AX
+	CMPQ	AX, $0x123
+	JEQ	h_ok
+	PUSHQ	$0xdeadbeed
+	PUSHQ	$0
+	CALL	runtime·pancake(SB)
+h_ok:
+	PUSHQ	$0x20
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0xdeadbeef
+	PUSHQ	$0
+	CALL	runtime·pancake(SB)
+	INT	$3
+
+
+	// set the per-goroutine and per-mach "registers"
+	get_tls(BX)
+	LEAQ	runtime·g0(SB), CX
+	MOVQ	CX, g(BX)
+	LEAQ	runtime·m0(SB), AX
+
+	// save m->g0 = g0
+	MOVQ	CX, m_g0(AX)
+	// save m0 to g0->m
+	MOVQ	AX, g_m(CX)
+
+	CLD				// convention is D is always left cleared
+	CALL	runtime·check(SB)
+
+	MOVL	16(SP), AX		// copy argc
+	MOVL	AX, 0(SP)
+	MOVQ	24(SP), AX		// copy argv
+	MOVQ	AX, 8(SP)
+	CALL	runtime·args(SB)
+	CALL	runtime·osinit(SB)
+	CALL	runtime·schedinit(SB)
+
+	// create a new goroutine to start program
+	MOVQ	$runtime·main·f(SB), BP		// entry
+	PUSHQ	BP
+	PUSHQ	$0			// arg size
+	CALL	runtime·newproc(SB)
+	POPQ	AX
+	POPQ	AX
+
+	// start this M
+	CALL	runtime·mstart(SB)
+
+	MOVL	$0xf1, 0xf1  // crash
+	RET
 
 	PUSHQ	$0x20
 	CALL	runtime·doc(SB)
@@ -134,7 +297,7 @@
 	CALL	runtime·doc(SB)
 	PUSHQ	$0x31
 	CALL	runtime·doc(SB)
-	PUSHQ	$0xdeadbeef
+	PUSHQ	$0xc001d00d
 	PUSHQ	$0
 	CALL	runtime·pancake(SB)
 	INT	$3
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/os_linux.c	Mon Dec 08 11:02:40 2014 -0500
@@ -368,7 +368,7 @@
 }
 
 #pragma textflag NOSPLIT
-static void
+void
 pnum(uint64 n)
 {
 	uint64 nn = (uint64)n;
@@ -377,7 +377,7 @@
 	for (i = 60; i >= 0; i -= 4) {
 		uint64 cn = (nn >> i) & 0xf;
 
-		if (cn >= 0 && cn <= 9)
+		if (cn <= 9)
 			runtime·doc('0' + cn);
 		else
 			runtime·doc('A' + cn - 10);
@@ -395,7 +395,7 @@
 
 #pragma textflag NOSPLIT
 void
-runtime·pancake(int8 *msg, int64 addr)
+runtime·pancake(void *msg, int64 addr)
 {
 	runtime·doc(' ');
 
@@ -406,3 +406,166 @@
 	pmsg(" PANCAKE");
 	while (1);
 }
+
+// gee i wish i could pack structs with plan9 compiler
+struct pdesc_t {
+	uint8 dur[10];
+};
+
+struct seg64_t {
+	uint8 dur[8];
+	// 0,1 low limit
+	// 2,3 low base
+	// 4   mid base
+	// 5   p, dpl, s, type
+	// 6   g, d/b, l, avl, mid limit
+	// 7   high base
+};
+
+#define	G	0x80
+#define	D	0x40
+#define	L	0x20
+
+#define	CODE	0xa
+#define	DATA	0x2
+
+static struct seg64_t segs[4] = {
+	// NULL seg
+	{0, 0, 0, 0, 0, 0, 0, 0},
+
+	// data
+	{0xff, 0xff,	// limit
+	 0, 0, 0,	// base
+	 0x90 | DATA,	// p, dpl, s, type
+	 G | D | 0xf,	// g, d/b, l, avail, mid limit
+	 0},		// base high
+
+	// fs seg
+	{0xff, 0xff,	// limit
+	 0, 0, 0,	// base
+	 0x90 | DATA,	// p, dpl, s, type
+	 G | D | 0xf,	// g, d/b, l, avail, mid limit
+	 0},		// base high
+
+	// 64 bit code
+	{0xff, 0xff,	// limit
+	 0, 0, 0,	// base
+	 0x90 | CODE,	// p, dpl, s, type
+	 G | L | 0xf,	// g, d/b, l, avail, mid limit
+	 0},		// base high
+
+};
+
+static struct pdesc_t pd;
+
+#define	FS_SEG		2
+
+#pragma textflag NOSPLIT
+static void
+seg_set_base(struct seg64_t *seg, uint32 base, uint32 lim)
+{
+	uint8 b1 = base & 0xff;
+	uint8 b2 = (base >>  8) & 0xff;
+	uint8 b3 = (base >> 16) & 0xff;
+	uint8 b4 = (base >> 24) & 0xff;
+
+	uint8 l1 = lim & 0xff;
+	uint8 l2 = (lim >>  8) & 0xff;
+	uint8 l3 = (lim >> 16) & 0xff;
+
+	seg->dur[0] = l1;
+	seg->dur[1] = l2;
+	seg->dur[6] = l3 | G | D;
+
+	seg->dur[2] = b1;
+	seg->dur[3] = b2;
+	seg->dur[4] = b3;
+	seg->dur[7] = b4;
+}
+
+#undef DATA
+#undef CODE
+#undef G
+#undef D
+#undef L
+
+#define	CHECK32(x)	(x & ~((1ULL << 32) - 1))
+
+#pragma textflag NOSPLIT
+static void
+pdsetup(struct pdesc_t *pd, struct seg64_t *s, uint64 lim)
+{
+	uint64 addr = (uint64)s;
+
+	pd->dur[0] = lim & 0xff;
+	pd->dur[1] = (lim >> 8) & 0xff;
+
+	pd->dur[2] = addr & 0xff;
+	pd->dur[3] = (addr >>  8) & 0xff;
+	pd->dur[4] = (addr >> 16) & 0xff;
+	pd->dur[5] = (addr >> 24) & 0xff;
+	pd->dur[6] = (addr >> 32) & 0xff;
+	pd->dur[7] = (addr >> 40) & 0xff;
+	pd->dur[8] = (addr >> 48) & 0xff;
+	pd->dur[9] = (addr >> 56) & 0xff;
+}
+
+#pragma textflag NOSPLIT
+static void
+memcpy(void *dst, void *src, uint64 sz)
+{
+	uint8 *t = dst;
+	uint8 *f = src;
+
+	while (sz--)
+		*t++ = *f++;
+}
+
+struct pdesc_t duhee;
+
+#pragma textflag NOSPLIT
+uint64
+runtime·segsetup(void *tls0)
+{
+	uint64 tlsaddr = (uint64)tls0;
+
+	// TLS assembles to -16(%fs)
+	tlsaddr += 16;
+	pmsg("tls0 is ");
+	pnum(tlsaddr);
+
+	if (sizeof(struct pdesc_t) != 10)
+		runtime·pancake("pdesc not packed", sizeof(struct pdesc_t));
+
+	if (sizeof(struct seg64_t) != 8)
+		runtime·pancake("seg64 not packed", sizeof(struct seg64_t));
+	if (sizeof(struct seg64_t)*4 != 32)
+		runtime·pancake("wut?", sizeof(struct seg64_t)*4);
+
+	// gee i wish i could align data with plan9 compiler
+	if ((uint64)&pd & 0x7)
+		runtime·pancake("pdesc not aligned", (uint64)&pd);
+
+	if (CHECK32(tlsaddr))
+		runtime·pancake("tlsaddr > 32bits, use msrs", tlsaddr);
+
+	seg_set_base(&segs[FS_SEG], (uint32)tlsaddr, 0xffffffff);
+	//extern uint32 runtime·first_free;
+	//struct seg64_t *fleabag = (struct seg64_t *)runtime·first_free;
+	//memcpy(fleabag, segs, sizeof(segs));
+	//pdsetup(&pd, fleabag, sizeof(segs) - 1);
+	pdsetup(&pd, segs, sizeof(segs) - 1);
+
+	//{
+	//uint32 *p = (uint32 *)&segs[3];
+	//pmsg("stuff ");
+	//pnum(*p++);
+	//pmsg(" ");
+	//pnum(*p++);
+	//while(1);
+	//}
+
+	pmsg("set segs");
+
+	return (uint64)&pd;
+}
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/panic.go
--- a/src/runtime/panic.go	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/panic.go	Mon Dec 08 11:02:40 2014 -0500
@@ -482,6 +482,7 @@
 
 //go:nosplit
 func throw(s *byte) {
+	pancake(s, 0x31337)
 	gp := getg()
 	if gp.m.throwing == 0 {
 		gp.m.throwing = 1
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/proc.c
--- a/src/runtime/proc.c	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/proc.c	Mon Dec 08 11:02:40 2014 -0500
@@ -51,6 +51,10 @@
 uintptr runtime·allglen;
 ForceGCState	runtime·forcegc;
 
+// biscuit stuff
+int32 pgtbl;
+int32 first_free;
+
 void runtime·mstart(void);
 static void runqput(P*, G*);
 static G* runqget(P*);
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/rt0_linux_amd64.s
--- a/src/runtime/rt0_linux_amd64.s	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/rt0_linux_amd64.s	Mon Dec 08 11:02:40 2014 -0500
@@ -9,6 +9,7 @@
 	MOVQ	0(SP), DI // argc
 	MOVQ	$main(SB), AX
 	CALL	AX
+	MOVL	$1, 0	// abort
 	CALL	_rt0_hack(SB)
 	INT	$3
 
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/stubs.go
--- a/src/runtime/stubs.go	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/stubs.go	Mon Dec 08 11:02:40 2014 -0500
@@ -122,6 +122,8 @@
 func readmemstats_m()
 func writeheapdump_m()
 
+func pancake(*byte, int)
+
 // memclr clears n bytes starting at ptr.
 // in memclr_*.s
 //go:noescape

changeset:   21877:0a7171e4df71
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Mon Dec 08 15:45:49 2014 -0500
summary:     finish segmentation

diff -r 3a1f8ad32b44 -r 0a7171e4df71 src/runtime/asm_amd64.s
--- a/src/runtime/asm_amd64.s	Mon Dec 08 11:02:40 2014 -0500
+++ b/src/runtime/asm_amd64.s	Mon Dec 08 15:45:49 2014 -0500
@@ -119,21 +119,25 @@
 	// No per-thread init.
 	RET
 
-TEXT retardtown(SB),NOSPLIT,$0
-	MOVQ	(SP), AX
+TEXT fixcs(SB),NOSPLIT,$0
+	POPQ	AX
 	PUSHQ	$(3 << 3)
 	PUSHQ	AX
-	// lret
+	// lretq
+	BYTE	$0x48
 	BYTE	$0xcb
+	MOVQ	$1, 0
+	//POPQ	DX
+	//MOVQ	$(3 << 3), AX
+	//SHLQ	$32, AX
+	//ORQ	DX, AX
+	//PUSHQ	AX
+	//// lret
+	//BYTE	$0xcb
+	//MOVQ	$1, 0
 
 TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
 
-//	CMPQ	DI, $0
-//	JEQ	duder
-//dud:
-//	JMP dud
-//duder:
-
 	// save page table and first free address from bootloader.
 	MOVL	DI, runtime·pgtbl(SB)
 	MOVL	SI, runtime·first_free(SB)
@@ -196,12 +200,6 @@
 	//CMPL	runtime·issolaris(SB), $1
 	//JEQ ok
 
-//	CMPQ	AX, $0
-//	JEQ	duder
-//dud:
-//	JMP dud
-//duder:
-
 	// setup tls
 	LEAQ	runtime·tls0(SB), DI
 	PUSHQ	DI
@@ -218,12 +216,24 @@
 	BYTE	$0x24
 	POPQ	AX
 	POPQ	AX
+	POPQ	AX
 
 	MOVQ	$(2 << 3), AX
 	PUSHQ	AX
 	POPQ	FS
 
-	//CALL retardtown(SB)
+	MOVL	$(1 << 3), AX
+	//MOVL	AX, ES
+	BYTE	$0x8e
+	BYTE	$0xd8
+	//MOVL	AX, DS
+	BYTE	$0x8e
+	BYTE	$0xc0
+	//MOVL	AX, SS
+	BYTE	$0x8e
+	BYTE	$0xd0
+
+	CALL fixcs(SB)
 
 	// store through it, to make sure it works
 	get_tls(BX)
@@ -231,22 +241,16 @@
 	MOVQ	runtime·tls0(SB), AX
 	CMPQ	AX, $0x123
 	JEQ	h_ok
-	PUSHQ	$0xdeadbeed
+	MOVQ	$0x4242424242424242, AX
+	PUSHQ	AX
 	PUSHQ	$0
 	CALL	runtime·pancake(SB)
+
 h_ok:
-	PUSHQ	$0x20
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0xdeadbeef
-	PUSHQ	$0
+	MOVQ	$0xc001d00ddeadbeef, AX
+	PUSHQ	AX
+	MOVQ	$runtime·madeit(SB), AX
+	PUSHQ	AX
 	CALL	runtime·pancake(SB)
 	INT	$3
 
diff -r 3a1f8ad32b44 -r 0a7171e4df71 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Mon Dec 08 11:02:40 2014 -0500
+++ b/src/runtime/os_linux.c	Mon Dec 08 15:45:49 2014 -0500
@@ -393,6 +393,8 @@
 			runtime·doc(*msg++);
 }
 
+uint8 runtime·madeit[] = "We made it!";
+
 #pragma textflag NOSPLIT
 void
 runtime·pancake(void *msg, int64 addr)
@@ -414,12 +416,6 @@
 
 struct seg64_t {
 	uint8 dur[8];
-	// 0,1 low limit
-	// 2,3 low base
-	// 4   mid base
-	// 5   p, dpl, s, type
-	// 6   g, d/b, l, avl, mid limit
-	// 7   high base
 };
 
 #define	G	0x80
@@ -453,7 +449,6 @@
 	 0x90 | CODE,	// p, dpl, s, type
 	 G | L | 0xf,	// g, d/b, l, avail, mid limit
 	 0},		// base high
-
 };
 
 static struct pdesc_t pd;
@@ -511,19 +506,6 @@
 }
 
 #pragma textflag NOSPLIT
-static void
-memcpy(void *dst, void *src, uint64 sz)
-{
-	uint8 *t = dst;
-	uint8 *f = src;
-
-	while (sz--)
-		*t++ = *f++;
-}
-
-struct pdesc_t duhee;
-
-#pragma textflag NOSPLIT
 uint64
 runtime·segsetup(void *tls0)
 {
@@ -531,8 +513,6 @@
 
 	// TLS assembles to -16(%fs)
 	tlsaddr += 16;
-	pmsg("tls0 is ");
-	pnum(tlsaddr);
 
 	if (sizeof(struct pdesc_t) != 10)
 		runtime·pancake("pdesc not packed", sizeof(struct pdesc_t));
@@ -549,23 +529,8 @@
 	if (CHECK32(tlsaddr))
 		runtime·pancake("tlsaddr > 32bits, use msrs", tlsaddr);
 
-	seg_set_base(&segs[FS_SEG], (uint32)tlsaddr, 0xffffffff);
-	//extern uint32 runtime·first_free;
-	//struct seg64_t *fleabag = (struct seg64_t *)runtime·first_free;
-	//memcpy(fleabag, segs, sizeof(segs));
-	//pdsetup(&pd, fleabag, sizeof(segs) - 1);
+	seg_set_base(&segs[FS_SEG], (uint32)tlsaddr, 15);
 	pdsetup(&pd, segs, sizeof(segs) - 1);
 
-	//{
-	//uint32 *p = (uint32 *)&segs[3];
-	//pmsg("stuff ");
-	//pnum(*p++);
-	//pmsg(" ");
-	//pnum(*p++);
-	//while(1);
-	//}
-
-	pmsg("set segs");
-
 	return (uint64)&pd;
 }

changeset:   21878:f2eefaeb0220
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Mon Dec 08 16:02:07 2014 -0500
summary:     x

diff -r 0a7171e4df71 -r f2eefaeb0220 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Mon Dec 08 15:45:49 2014 -0500
+++ b/src/runtime/os_linux.c	Mon Dec 08 16:02:07 2014 -0500
@@ -429,25 +429,27 @@
 	// NULL seg
 	{0, 0, 0, 0, 0, 0, 0, 0},
 
+	// limits and base are ignored (except for fs/gs) in long mode.
+
 	// data
-	{0xff, 0xff,	// limit
+	{0, 0,		// limit
 	 0, 0, 0,	// base
 	 0x90 | DATA,	// p, dpl, s, type
-	 G | D | 0xf,	// g, d/b, l, avail, mid limit
+	 G | D,	// g, d/b, l, avail, mid limit
 	 0},		// base high
 
 	// fs seg
-	{0xff, 0xff,	// limit
+	{0, 0,		// limit
 	 0, 0, 0,	// base
 	 0x90 | DATA,	// p, dpl, s, type
-	 G | D | 0xf,	// g, d/b, l, avail, mid limit
+	 G | D | 0,	// g, d/b, l, avail, mid limit
 	 0},		// base high
 
 	// 64 bit code
-	{0xff, 0xff,	// limit
+	{0, 0,		// limit
 	 0, 0, 0,	// base
 	 0x90 | CODE,	// p, dpl, s, type
-	 G | L | 0xf,	// g, d/b, l, avail, mid limit
+	 G | L | 0,	// g, d/b, l, avail, mid limit
 	 0},		// base high
 };
 

changeset:   21879:bec1a051a8a2
tag:         tip
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Tue Dec 09 16:58:57 2014 -0500
summary:     64bit interrupts

diff -r f2eefaeb0220 -r bec1a051a8a2 src/runtime/asm_amd64.s
--- a/src/runtime/asm_amd64.s	Mon Dec 08 16:02:07 2014 -0500
+++ b/src/runtime/asm_amd64.s	Tue Dec 09 16:58:57 2014 -0500
@@ -119,9 +119,13 @@
 	// No per-thread init.
 	RET
 
+#define		CODESEG		1
+#define		DATASEG		2
+#define		FSSEG		3
+
 TEXT fixcs(SB),NOSPLIT,$0
 	POPQ	AX
-	PUSHQ	$(3 << 3)
+	PUSHQ	$(CODESEG << 3)
 	PUSHQ	AX
 	// lretq
 	BYTE	$0x48
@@ -136,11 +140,22 @@
 	//BYTE	$0xcb
 	//MOVQ	$1, 0
 
+TEXT runtime·deray(SB),NOSPLIT,$8
+	MOVQ	times+0(FP), CX
+	MOVQ	$0x80, DX
+	MOVQ	$0, AX
+back:
+	// outb	%al, (%dx)
+	BYTE	$0xee
+	LOOP	back
+	RET
+
 TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
 
 	// save page table and first free address from bootloader.
 	MOVL	DI, runtime·pgtbl(SB)
 	MOVL	SI, runtime·first_free(SB)
+	MOVL	$1, hackmode(SB)
 
 	ANDQ	$~15, SP
 
@@ -218,11 +233,11 @@
 	POPQ	AX
 	POPQ	AX
 
-	MOVQ	$(2 << 3), AX
+	MOVQ	$(FSSEG << 3), AX
 	PUSHQ	AX
 	POPQ	FS
 
-	MOVL	$(1 << 3), AX
+	MOVL	$(DATASEG << 3), AX
 	//MOVL	AX, ES
 	BYTE	$0x8e
 	BYTE	$0xd8
@@ -233,7 +248,9 @@
 	BYTE	$0x8e
 	BYTE	$0xd0
 
-	CALL fixcs(SB)
+	// i cannot fix CS via far call to a label because i don't know how to
+	// call a label with plan9 compiler.
+	CALL	fixcs(SB)
 
 	// store through it, to make sure it works
 	get_tls(BX)
@@ -245,15 +262,7 @@
 	PUSHQ	AX
 	PUSHQ	$0
 	CALL	runtime·pancake(SB)
-
 h_ok:
-	MOVQ	$0xc001d00ddeadbeef, AX
-	PUSHQ	AX
-	MOVQ	$runtime·madeit(SB), AX
-	PUSHQ	AX
-	CALL	runtime·pancake(SB)
-	INT	$3
-
 
 	// set the per-goroutine and per-mach "registers"
 	get_tls(BX)
@@ -266,6 +275,26 @@
 	// save m0 to g0->m
 	MOVQ	AX, g_m(CX)
 
+	CALL	intsetup(SB)
+
+	// TS is set?
+	//MOVQ	CR0, AX
+	//ANDQ	$~(1 << 3), AX
+	//MOVQ	AX, CR0
+
+	//MOVQ	CR0, AX
+	//// MP
+	//ORL	$(1 << 1), AX
+	//// NE
+	////ORL	$(1 << 5), AX
+	//MOVQ	AX, CR0
+	FINIT
+	//fninit
+	//BYTE	$0xdb
+	//BYTE	$0xe3
+
+	CALL	wemadeit(SB)
+
 	CLD				// convention is D is always left cleared
 	CALL	runtime·check(SB)
 
@@ -291,20 +320,80 @@
 	MOVL	$0xf1, 0xf1  // crash
 	RET
 
-	PUSHQ	$0x20
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0xc001d00d
-	PUSHQ	$0
-	CALL	runtime·pancake(SB)
-	INT	$3
+TEXT lidt(SB), NOSPLIT, $0-8
+	MOVQ	idtpd+0(FP), AX
+	MOVQ	8(AX), DI
+	PUSHQ	DI
+	MOVQ	(AX), DI
+	PUSHQ	DI
+	// lidt	(%rsp)
+	BYTE	$0x0f
+	BYTE	$0x01
+	BYTE	$0x1c
+	BYTE	$0x24
+	POPQ	AX
+	POPQ	AX
+	RET
+
+TEXT ltr(SB), NOSPLIT, $0-8
+	MOVQ	seg+0(FP), AX
+	// ltr	%ax
+	BYTE $0x0f
+	BYTE $0x00
+	BYTE $0xd8
+	RET
+
+#define IH_NOEC(num, fn)		\
+TEXT fn(SB), NOSPLIT, $0-0;		\
+	PUSHQ	$0;			\
+	PUSHQ	$num;			\
+	JMP	alltraps(SB);		\
+	BYTE	$0xeb;			\
+	BYTE	$0xfe;			\
+	POPQ	AX;			\
+	POPQ	AX;			\
+	RET
+
+#define IH_EC(num, fn)			\
+TEXT fn(SB), NOSPLIT, $0-0;		\
+	PUSHQ	$num;			\
+	JMP	alltraps(SB);		\
+	BYTE	$0xeb;			\
+	BYTE	$0xfe;			\
+	POPQ	AX;			\
+	POPQ	AX;			\
+	RET
+
+IH_NOEC( 0,Xdz )
+IH_NOEC( 1,Xrz )
+IH_NOEC( 2,Xnmi )
+IH_NOEC( 3,Xbp )
+IH_NOEC( 4,Xov )
+IH_NOEC( 5,Xbnd )
+IH_NOEC( 6,Xuo )
+IH_NOEC( 7,Xnm )
+IH_EC  ( 8,Xdf )
+IH_NOEC( 9,Xrz2 )
+IH_EC  (10,Xtss )
+IH_EC  (11,Xsnp )
+IH_EC  (12,Xssf )
+IH_EC  (13,Xgp )
+IH_EC  (14,Xpf )
+IH_NOEC(15,Xrz3 )
+IH_NOEC(16,Xmf )
+IH_EC  (17,Xac )
+IH_NOEC(18,Xmc )
+IH_NOEC(19,Xfp )
+IH_NOEC(20,Xve )
+
+TEXT alltraps(SB), NOSPLIT, $0-0
+	MOVQ	SP, AX
+	PUSHQ	AX
+	CALL	trap(SB)
+	BYTE	$0xeb
+	BYTE	$0xfe
+	POPQ	AX
+	RET
 
 /*
  *  go-routine
diff -r f2eefaeb0220 -r bec1a051a8a2 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Mon Dec 08 16:02:07 2014 -0500
+++ b/src/runtime/os_linux.c	Tue Dec 09 16:58:57 2014 -0500
@@ -385,7 +385,7 @@
 }
 
 #pragma textflag NOSPLIT
-static void
+void
 pmsg(int8 *msg)
 {
 	if (msg)
@@ -393,8 +393,6 @@
 			runtime·doc(*msg++);
 }
 
-uint8 runtime·madeit[] = "We made it!";
-
 #pragma textflag NOSPLIT
 void
 runtime·pancake(void *msg, int64 addr)
@@ -409,6 +407,13 @@
 	while (1);
 }
 
+#pragma textflag NOSPLIT
+static void
+bw(uint8 *d, uint64 data, uint64 off)
+{
+	*d = (data >> off*8) & 0xff;
+}
+
 // gee i wish i could pack structs with plan9 compiler
 struct pdesc_t {
 	uint8 dur[10];
@@ -424,12 +429,20 @@
 
 #define	CODE	0xa
 #define	DATA	0x2
+#define	TSS	0x9
 
-static struct seg64_t segs[4] = {
+static struct seg64_t segs[6] = {
 	// NULL seg
 	{0, 0, 0, 0, 0, 0, 0, 0},
 
-	// limits and base are ignored (except for fs/gs) in long mode.
+	// limits and base are ignored for CS, DS, and ES in long mode.
+
+	// 64 bit code
+	{0, 0,		// limit
+	 0, 0, 0,	// base
+	 0x90 | CODE,	// p, dpl, s, type
+	 G | L,		// g, d/b, l, avail, mid limit
+	 0},		// base high
 
 	// data
 	{0, 0,		// limit
@@ -442,37 +455,46 @@
 	{0, 0,		// limit
 	 0, 0, 0,	// base
 	 0x90 | DATA,	// p, dpl, s, type
-	 G | D | 0,	// g, d/b, l, avail, mid limit
+	 G | D,		// g, d/b, l, avail, mid limit
 	 0},		// base high
 
-	// 64 bit code
+	// tss seg
 	{0, 0,		// limit
 	 0, 0, 0,	// base
-	 0x90 | CODE,	// p, dpl, s, type
-	 G | L | 0,	// g, d/b, l, avail, mid limit
+	 0x80 | TSS,	// p, dpl, s, type
+	 G,		// g, d/b, l, avail, mid limit
 	 0},		// base high
+	// 64 bit tss takes up two segment descriptor entires. the high 32bits
+	// of the base are written in this seg desc.
+	{0, 0, 0, 0, 0, 0, 0, 0},
 };
 
 static struct pdesc_t pd;
 
-#define	FS_SEG		2
+#define	CODE_SEG	1
+#define	FS_SEG		3
+#define	TSS_SEG		4
 
 #pragma textflag NOSPLIT
 static void
-seg_set_base(struct seg64_t *seg, uint32 base, uint32 lim)
+seg_set(struct seg64_t *seg, uint32 base, uint32 lim, uint32 data)
 {
 	uint8 b1 = base & 0xff;
 	uint8 b2 = (base >>  8) & 0xff;
 	uint8 b3 = (base >> 16) & 0xff;
 	uint8 b4 = (base >> 24) & 0xff;
 
+	// correct limit
 	uint8 l1 = lim & 0xff;
 	uint8 l2 = (lim >>  8) & 0xff;
-	uint8 l3 = (lim >> 16) & 0xff;
+	uint8 l3 = (lim >> 16) & 0xf;
 
 	seg->dur[0] = l1;
 	seg->dur[1] = l2;
-	seg->dur[6] = l3 | G | D;
+	if (data)
+		seg->dur[6] = l3 | G | D;
+	else
+		seg->dur[6] = l3 | G;
 
 	seg->dur[2] = b1;
 	seg->dur[3] = b2;
@@ -482,6 +504,7 @@
 
 #undef DATA
 #undef CODE
+#undef TSS
 #undef G
 #undef D
 #undef L
@@ -490,7 +513,7 @@
 
 #pragma textflag NOSPLIT
 static void
-pdsetup(struct pdesc_t *pd, struct seg64_t *s, uint64 lim)
+pdsetup(struct pdesc_t *pd, uint64 s, uint64 lim)
 {
 	uint64 addr = (uint64)s;
 
@@ -531,8 +554,213 @@
 	if (CHECK32(tlsaddr))
 		runtime·pancake("tlsaddr > 32bits, use msrs", tlsaddr);
 
-	seg_set_base(&segs[FS_SEG], (uint32)tlsaddr, 15);
-	pdsetup(&pd, segs, sizeof(segs) - 1);
+	seg_set(&segs[FS_SEG], (uint32)tlsaddr, 15, 1);
+	pdsetup(&pd, (uint64)segs, sizeof(segs) - 1);
 
 	return (uint64)&pd;
 }
+
+#pragma textflag NOSPLIT
+void
+marksleep(int8 *msg)
+{
+	pmsg(" ");
+	pmsg(msg);
+	extern void runtime·deray(uint64);
+	runtime·deray(5000000);
+}
+
+struct idte_t {
+	uint8 dur[16];
+};
+
+#define	INT		0xe
+#define	TRAP		0xf
+
+/*
+{0, 0,		// 0-1   low offset
+ CODE_SEG, 0,	// 2-3   segment
+ 0,		// 4     ist
+ 0x80 | INT,	// 5     p, dpl, type
+ 0, 0,		// 6-7   mid offset
+ 0, 0, 0, 0,	// 8-11  high offset
+ 0, 0, 0, 0},	// 12-15 resreved
+ */
+#define INTR	\
+	{0, 0,		\
+	 CODE_SEG, 0,	\
+	 0,		\
+	 0x80 | INT,	\
+	 0, 0,		\
+	 0, 0, 0, 0,	\
+	 0, 0, 0, 0},	\
+
+#define	NIDTE		64
+struct idte_t idt[NIDTE];
+
+#pragma textflag NOSPLIT
+static void
+int_set(struct idte_t *i, uint64 addr, uint64 trap)
+{
+	uint16 lowoff  = (uint16)addr;
+	uint16 midoff  = (addr >> 16) & 0xffff;
+	uint32 highoff = addr >> 32;
+
+	bw(&i->dur[0],  lowoff, 0);
+	bw(&i->dur[1],  lowoff, 1);
+	bw(&i->dur[2], CODE_SEG << 3, 0);
+	bw(&i->dur[3], CODE_SEG << 3, 1);
+	i->dur[4] = 0;
+	if (trap)
+		i->dur[5] = 0x80 | TRAP;
+	else
+		i->dur[5] = 0x80 | INT;
+	bw(&i->dur[6],  midoff, 0);
+	bw(&i->dur[7],  midoff, 1);
+	bw(&i->dur[8],  highoff, 0);
+	bw(&i->dur[9],  highoff, 1);
+	bw(&i->dur[10], highoff, 2);
+	bw(&i->dur[11], highoff, 3);
+}
+
+#undef INT
+#undef TRAP
+
+struct tss_t {
+	uint8 dur[26];
+};
+
+struct tss_t tss;
+
+static void
+tss_set(struct tss_t *tss, uint64 rsp0)
+{
+	uint32 off = 4;		// offset to rsp0 field
+
+	bw(&tss->dur[off + 0], rsp0, 0);
+	bw(&tss->dur[off + 1], rsp0, 1);
+	bw(&tss->dur[off + 2], rsp0, 2);
+	bw(&tss->dur[off + 3], rsp0, 3);
+	bw(&tss->dur[off + 4], rsp0, 4);
+	bw(&tss->dur[off + 5], rsp0, 5);
+	bw(&tss->dur[off + 6], rsp0, 6);
+	bw(&tss->dur[off + 7], rsp0, 7);
+
+	// disable io bitmap
+	uint64 d = sizeof(struct tss_t);
+	bw(&tss->dur[102], d, 0);
+	bw(&tss->dur[103], d, 1);
+}
+
+#pragma textflag NOSPLIT
+static void
+tss_setup(void)
+{
+	// alignment is for performance
+	uint64 addr = (uint64)&tss;
+	if (addr & (16 - 1))
+		runtime·pancake("tss not aligned", addr);
+
+	// XXX get real stack
+	uint64 rsp = 0x80000000 - 8;
+	// XXX dur
+	*(uint64 *)rsp = 0;
+
+	tss_set(&tss, rsp);
+	seg_set(&segs[TSS_SEG], (uint32)addr, sizeof(tss) - 1, 0);
+
+	// set high bits (TSS64 uses two segment descriptors
+	uint32 haddr = addr >> 32;
+	bw(&segs[TSS_SEG + 1].dur[0], haddr, 0);
+	bw(&segs[TSS_SEG + 1].dur[1], haddr, 1);
+	bw(&segs[TSS_SEG + 1].dur[2], haddr, 2);
+	bw(&segs[TSS_SEG + 1].dur[3], haddr, 3);
+
+	extern void ltr(uint64);
+	ltr(TSS_SEG << 3);
+}
+
+extern void lidt(struct pdesc_t *);
+
+#pragma textflag NOSPLIT
+void
+intsetup(void)
+{
+	struct pdesc_t p;
+
+	if (sizeof(struct idte_t) != 16)
+		runtime·pancake("idte not packed", sizeof(struct idte_t));
+	if (sizeof(idt) != 16*NIDTE)
+		runtime·pancake("idt not packed", sizeof(idt));
+
+	if ((uint64)idt & 0x7)
+		runtime·pancake("idt not aligned", (uint64)idt);
+
+	extern void Xdz (void);
+	extern void Xrz (void);
+	extern void Xnmi(void);
+	extern void Xbp (void);
+	extern void Xov (void);
+	extern void Xbnd(void);
+	extern void Xuo (void);
+	extern void Xnm (void);
+	extern void Xdf (void);
+	extern void Xrz2(void);
+	extern void Xtss(void);
+	extern void Xsnp(void);
+	extern void Xssf(void);
+	extern void Xgp (void);
+	extern void Xpf (void);
+	extern void Xrz3(void);
+	extern void Xmf (void);
+	extern void Xac (void);
+	extern void Xmc (void);
+	extern void Xfp (void);
+	extern void Xve (void);
+
+	int_set(&idt[ 0], (uint64) Xdz , 0);
+	int_set(&idt[ 1], (uint64) Xrz , 0);
+	int_set(&idt[ 2], (uint64) Xnmi, 0);
+	int_set(&idt[ 3], (uint64) Xbp , 0);
+	int_set(&idt[ 4], (uint64) Xov , 0);
+	int_set(&idt[ 5], (uint64) Xbnd, 0);
+	int_set(&idt[ 6], (uint64) Xuo , 0);
+	int_set(&idt[ 7], (uint64) Xnm , 0);
+	int_set(&idt[ 8], (uint64) Xdf , 0);
+	int_set(&idt[ 9], (uint64) Xrz2, 0);
+	int_set(&idt[10], (uint64) Xtss, 0);
+	int_set(&idt[11], (uint64) Xsnp, 0);
+	int_set(&idt[12], (uint64) Xssf, 0);
+	int_set(&idt[13], (uint64) Xgp , 0);
+	int_set(&idt[14], (uint64) Xpf , 0);
+	int_set(&idt[15], (uint64) Xrz3, 0);
+	int_set(&idt[16], (uint64) Xmf , 0);
+	int_set(&idt[17], (uint64) Xac , 0);
+	int_set(&idt[18], (uint64) Xmc , 0);
+	int_set(&idt[19], (uint64) Xfp , 0);
+	int_set(&idt[20], (uint64) Xve , 0);
+
+	pdsetup(&p, (uint64)idt, sizeof(idt) - 1);
+	lidt(&p);
+
+	tss_setup();
+}
+
+#pragma textflag NOSPLIT
+void
+trap(uint64 *tf)
+{
+	pmsg("trap frame at ");
+	pnum((uint64)tf);
+
+	uint64 trapno = *tf;
+	runtime·pancake("interrupt ", trapno);
+}
+
+#pragma textflag NOSPLIT
+void
+wemadeit(void)
+{
+	runtime·pancake(" We made it! ", 0xc001d00dc001d00dULL);
+	while(1);
+}
diff -r f2eefaeb0220 -r bec1a051a8a2 src/runtime/proc.c
--- a/src/runtime/proc.c	Mon Dec 08 16:02:07 2014 -0500
+++ b/src/runtime/proc.c	Tue Dec 09 16:58:57 2014 -0500
@@ -54,6 +54,7 @@
 // biscuit stuff
 int32 pgtbl;
 int32 first_free;
+int32 hackmode;
 
 void runtime·mstart(void);
 static void runqput(P*, G*);
diff -r f2eefaeb0220 -r bec1a051a8a2 src/runtime/runtime.c
--- a/src/runtime/runtime.c	Mon Dec 08 16:02:07 2014 -0500
+++ b/src/runtime/runtime.c	Tue Dec 09 16:58:57 2014 -0500
@@ -193,6 +193,11 @@
 		byte y;
 	};
 
+	extern int32 hackmode;
+	extern void marksleep(int8 *);
+	if (hackmode)
+		marksleep("check start");
+
 	if(sizeof(a) != 1) runtime·throw("bad a");
 	if(sizeof(b) != 1) runtime·throw("bad b");
 	if(sizeof(c) != 2) runtime·throw("bad c");
@@ -209,6 +214,9 @@
 	if(offsetof(struct y1, y) != 1) runtime·throw("bad offsetof y1.y");
 	if(sizeof(struct y1) != 2) runtime·throw("bad sizeof y1");
 
+	if (hackmode)
+		marksleep("mark 1");
+
 	if(runtime·timediv(12345LL*1000000000+54321, 1000000000, &e) != 12345 || e != 54321)
 		runtime·throw("bad timediv");
 
@@ -225,23 +233,42 @@
 	if(z != 4)
 		runtime·throw("cas4");
 
+	if (hackmode)
+		marksleep("mark 2");
+
 	k = (byte*)0xfedcb123;
 	if(sizeof(void*) == 8)
 		k = (byte*)((uintptr)k<<10);
 	if(runtime·casp((void**)&k, nil, nil))
 		runtime·throw("casp1");
+
 	k1 = k+1;
 	if(!runtime·casp((void**)&k, k, k1))
 		runtime·throw("casp2");
+
 	if(k != k1)
 		runtime·throw("casp3");
 
+	if (hackmode)
+		marksleep("mark 2.3");
+
 	*(uint64*)&j = ~0ULL;
-	if(j == j)
+	if (hackmode)
+		while(1);	// hit!
+	if(j == j) {
+		while(1);	// not hit!
 		runtime·throw("float64nan");
+	}
+
+	if (hackmode)
+		marksleep("mark 2.4");
+
 	if(!(j != j))
 		runtime·throw("float64nan1");
 
+	if (hackmode)
+		marksleep("mark 3");
+
 	*(uint64*)&j1 = ~1ULL;
 	if(j == j1)
 		runtime·throw("float64nan2");
@@ -254,6 +281,9 @@
 	if(!(i != i))
 		runtime·throw("float32nan1");
 
+	if (hackmode)
+		marksleep("mark 4");
+
 	*(uint32*)&i1 = ~1UL;
 	if(i == i1)
 		runtime·throw("float32nan2");
@@ -264,6 +294,9 @@
 
 	if(FixedStack != runtime·round2(FixedStack))
 		runtime·throw("FixedStack is not power-of-2");
+
+	if (hackmode)
+		marksleep("mark 5");
 }
 
 #pragma dataflag NOPTR

