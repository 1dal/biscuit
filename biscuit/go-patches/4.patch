changeset:   21874:7fbeea021a7d
parent:      21811:ffe33f1f1f17
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Mon Dec 01 19:25:36 2014 -0500
summary:     clear bss, enable paging

diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/asm_386.s
--- a/src/runtime/asm_386.s	Tue Nov 25 15:41:33 2014 +1100
+++ b/src/runtime/asm_386.s	Mon Dec 01 19:25:36 2014 -0500
@@ -115,6 +115,43 @@
 DATA	runtime·main·f+0(SB)/4,$runtime·main(SB)
 GLOBL	runtime·main·f(SB),RODATA,$4
 
+//DATA	runtime·pgd+0(SB)/4,$0
+GLOBL	runtime·pgd(SB),NOPTR,$4
+
+TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
+	MOVL	$0x7c00, SP
+
+	CALL	runtime·pginit(SB)
+
+	PUSHL	$0x20
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+	PUSHL	$0x31
+	CALL	runtime·doc(SB)
+fleabag:
+	JMP	fleabag
+
+TEXT runtime·lcr3(SB),NOSPLIT,$0-4
+	MOVL	pgt+0(FP), AX
+	MOVL	AX, CR3
+	RET
+
+TEXT runtime·rcr3(SB),NOSPLIT,$0-4
+	MOVL	CR3, AX
+	MOVL	AX, ret+0(FP)
+	RET
+
+TEXT runtime·enable_paging(SB),NOSPLIT,$0-0
+	MOVL	CR0, AX
+	ORL	$(1 << 31), AX	// PAGING ENABLE
+	MOVL	AX, CR0
+	RET
+
 TEXT runtime·breakpoint(SB),NOSPLIT,$0-0
 	INT $3
 	RET
diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/hackstuff.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/runtime/hackstuff.h	Mon Dec 01 19:25:36 2014 -0500
@@ -0,0 +1,50 @@
+#ifndef _HACKSTUFF_H
+#define _HACKSTUFF_H
+
+struct Elf {
+	uint32 e_magic;
+#define ELF_MAGIC 0x464C457FU	/* "\x7FELF" in little endian */
+	uint8 e_elf[12];
+	uint16 e_type;
+	uint16 e_machine;
+	uint32 e_version;
+	uint32 e_entry;
+	uint32 e_phoff;
+	uint32 e_shoff;
+	uint32 e_flags;
+	uint16 e_ehsize;
+	uint16 e_phentsize;
+	uint16 e_phnum;
+	uint16 e_shentsize;
+	uint16 e_shnum;
+	uint16 e_shstrndx;
+};
+
+struct Proghdr {
+	uint32 p_type;
+	uint32 p_offset;
+	uint32 p_va;
+	uint32 p_pa;
+	uint32 p_filesz;
+	uint32 p_memsz;
+	uint32 p_flags;
+	uint32 p_align;
+};
+
+#define PGSIZE          (1UL << 12)
+#define PGOFFMASK       (PGSIZE - 1)
+#define PGMASK          (~PGOFFMASK)
+
+#define ROUNDDOWN(x, y) ((x) & ~((y) - 1))
+#define ROUNDUP(x, y)   (((x) + ((y) - 1)) & ~((y) - 1))
+
+#define PDX(x)          (((x) >> 22) & 0x3ff)
+#define PTX(x)          (((x) >> 12) & 0x3ff)
+
+#define PTE_P           (1 << 0)
+#define PTE_W           (1 << 1)
+#define PTE_U           (1 << 2)
+
+#define PTE_ADDR(x)     ((x) & ~0x3ff)
+
+#endif
diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/os_linux_386.c
--- a/src/runtime/os_linux_386.c	Tue Nov 25 15:41:33 2014 +1100
+++ b/src/runtime/os_linux_386.c	Mon Dec 01 19:25:36 2014 -0500
@@ -36,3 +36,197 @@
 		}
 	}
 }
+
+#pragma textflag NOSPLIT
+static void
+putch(int8 x, int8 y, int8 c)
+{
+        int16 *cons = (int16 *)0xb8000;
+        cons[y*80 + x] = 0x07 << 8 | c;
+}
+
+#pragma textflag NOSPLIT
+void
+runtime·doc(int64 mark)
+{
+        static int8 x;
+        static int8 y;
+
+        putch(x++, y, mark & 0xff);
+        //putch(x++, y, ' ');
+        if (x >= 79) {
+                x = 0;
+                y++;
+        }
+
+	if (y >= 29)
+		y = 0;
+}
+
+#pragma textflag NOSPLIT
+static void
+pnum(int64 n)
+{
+	int32 nn = (int32)n;
+	int32 i;
+
+	//for (i = 60; i >= 0; i -= 4) {
+	for (i = 28; i >= 0; i -= 4) {
+		int32 cn = (nn >> i) & 0xf;
+
+		if (cn >= 0 && cn <= 9)
+			runtime·doc('0' + cn);
+		else
+			runtime·doc('A' + cn - 10);
+	}
+}
+
+#pragma textflag NOSPLIT
+static void
+pmsg(int8 *msg)
+{
+	while (*msg)
+		runtime·doc(*msg++);
+}
+
+
+#pragma textflag NOSPLIT
+static void
+pancake(int8 *msg, int64 addr)
+{
+	runtime·doc(' ');
+
+	pmsg(msg);
+
+	runtime·doc(' ');
+	pnum(addr);
+	pmsg(" PANCAKE");
+	while (1);
+}
+
+#include "hackstuff.h"
+
+#pragma textflag NOSPLIT
+static uint32
+getpg(void)
+{
+	static uint32 last;
+
+	extern uint8 runtime·end[];
+	if (!last)
+		last = ROUNDUP((uint32)runtime·end, PGSIZE);
+
+	uint32 ret = last;
+	last += PGSIZE;
+
+	if (ret & PGOFFMASK)
+		pancake("not aligned", ret);
+
+	if (ret >= 0xc0000000 || ret < 0x01000000)
+		pancake("weird addr", ret);
+
+	int32 i;
+	for (i = 0; i < PGSIZE/4; i++)
+		((uint32 *)ret)[i] = 0;
+
+	return ret;
+}
+
+#pragma textflag NOSPLIT
+static void
+mapone(uint32 *pgd, uint32 va, uint32 pa)
+{
+	if (pa & PGOFFMASK)
+		pancake("pa not aligned", pa);
+
+	uint32 pde = pgd[PDX(va)];
+
+	if (!(pde & PTE_P)) {
+		pde = getpg() | PTE_P | PTE_W;
+		pgd[PDX(va)] = pde;
+	}
+
+	uint32 *pgt = (uint32 *)PTE_ADDR(pde);
+
+	if (pgt[PTX(va)] & PTE_P)
+		pancake("already mapped?", PTE_ADDR(pgt[PTX(va)]));
+
+	pgt[PTX(va)] = pa | PTE_P | PTE_W;
+}
+
+#pragma textflag NOSPLIT
+static void
+bootmap(uint32 *pgd, uint32 va, uint32 pa, uint32 sz)
+{
+	int32 i;
+	for (i = 0; i < sz; i += PGSIZE)
+		mapone(pgd, va + i, pa + i);
+}
+
+#pragma textflag NOSPLIT
+static void
+addsegs(struct Elf *e, uint32 *pgd)
+{
+	struct Proghdr *ph = (struct Proghdr *)((int8 *)e + e->e_phoff);
+	struct Proghdr *eph = ph + e->e_phnum;
+
+	for (; ph < eph; ph++) {
+		if (ph->p_type != 1) // PT_LOAD
+			continue;
+
+		bootmap(pgd, ph->p_pa, ph->p_pa, ph->p_memsz);
+	}
+}
+
+#pragma textflag NOSPLIT
+static void
+bsshack(void)
+{
+#define SAVE(x)	((uint32 *)(((uint32 *)0x7e00)[x]))
+	uint32 *start = SAVE(0);
+	uint32 *end = SAVE(1);
+#undef SAVE
+	while (start < end)
+		*start++ = 0;
+}
+
+extern uint32 *runtime·pgd;
+extern void runtime·lcr3(uint32);
+extern uint32 runtime·rcr3(void);
+extern void runtime·enable_paging(void);
+
+#pragma textflag NOSPLIT
+void
+runtime·pginit(void)
+{
+	int32 i;
+
+	// XXX the bootloader and this code assume there is at least ~130 MB of
+	// physical memory. should parse the e820 map.
+	bsshack();
+
+	runtime·pgd = (uint32 *)getpg();
+	if ((uint32)runtime·pgd & PGOFFMASK)
+		pancake("pgd not aligned?", (uint32)runtime·pgd);
+
+	for (i = 0; i < 1024; i++)
+		runtime·pgd[i] = 0;
+
+	// sweet hack -- header is still at physical address 0x10000
+	struct Elf *e = (struct Elf *)0x10000;
+	addsegs(e, runtime·pgd);
+	// give us VGA so we can print
+	mapone(runtime·pgd, 0xb8000, 0xb8000);
+	// and our stack
+	mapone(runtime·pgd, 0x7000, 0x7000);
+
+	runtime·lcr3((uint32)runtime·pgd);
+	pmsg("loaded cr3 ");
+	runtime·enable_paging();
+	pmsg("paging enabled ");
+	uint32 cr3 = runtime·rcr3();
+	pmsg("cr3 is ");
+	pnum(cr3);
+	//*(byte *)0 = 1;
+	//pmsg("wut");
+}
diff -r ffe33f1f1f17 -r 7fbeea021a7d src/runtime/rt0_linux_386.s
--- a/src/runtime/rt0_linux_386.s	Tue Nov 25 15:41:33 2014 +1100
+++ b/src/runtime/rt0_linux_386.s	Mon Dec 01 19:25:36 2014 -0500
@@ -12,6 +12,7 @@
 	CALL	runtime·linux_setup_vdso(SB)
 	CALL	main(SB)
 	INT	$3
+	CALL	_rt0_hack(SB)
 
 TEXT main(SB),NOSPLIT,$0
 	JMP	runtime·rt0_go(SB)
@@ -23,3 +24,6 @@
 DATA	runtime·_vdso(SB)/4, $_fallback_vdso(SB)
 GLOBL	runtime·_vdso(SB), NOPTR, $4
 
+TEXT _rt0_hack(SB),NOSPLIT,$0
+	CALL	runtime·rt0_go_hack(SB)
+	INT	$3

changeset:   21875:c2306e1c8f08
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Tue Dec 02 21:38:36 2014 -0500
summary:     use amd64 instead

diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/asm_386.s
--- a/src/runtime/asm_386.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/asm_386.s	Tue Dec 02 21:38:36 2014 -0500
@@ -115,43 +115,6 @@
 DATA	runtime·main·f+0(SB)/4,$runtime·main(SB)
 GLOBL	runtime·main·f(SB),RODATA,$4
 
-//DATA	runtime·pgd+0(SB)/4,$0
-GLOBL	runtime·pgd(SB),NOPTR,$4
-
-TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
-	MOVL	$0x7c00, SP
-
-	CALL	runtime·pginit(SB)
-
-	PUSHL	$0x20
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-	PUSHL	$0x31
-	CALL	runtime·doc(SB)
-fleabag:
-	JMP	fleabag
-
-TEXT runtime·lcr3(SB),NOSPLIT,$0-4
-	MOVL	pgt+0(FP), AX
-	MOVL	AX, CR3
-	RET
-
-TEXT runtime·rcr3(SB),NOSPLIT,$0-4
-	MOVL	CR3, AX
-	MOVL	AX, ret+0(FP)
-	RET
-
-TEXT runtime·enable_paging(SB),NOSPLIT,$0-0
-	MOVL	CR0, AX
-	ORL	$(1 << 31), AX	// PAGING ENABLE
-	MOVL	AX, CR0
-	RET
-
 TEXT runtime·breakpoint(SB),NOSPLIT,$0-0
 	INT $3
 	RET
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/asm_amd64.s
--- a/src/runtime/asm_amd64.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/asm_amd64.s	Tue Dec 02 21:38:36 2014 -0500
@@ -119,6 +119,26 @@
 	// No per-thread init.
 	RET
 
+TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
+	//MOVL	$0x7c00, SP
+
+	//CALL	runtime·pginit(SB)
+
+	PUSHQ	$0x20
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0xdeadbeef
+	PUSHQ	$0
+	CALL	runtime·pancake(SB)
+	INT	$3
+
 /*
  *  go-routine
  */
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/os_linux.c	Tue Dec 02 21:38:36 2014 -0500
@@ -340,3 +340,69 @@
 {
 	return runtime·sigtab[sig].name;
 }
+
+#pragma textflag NOSPLIT
+static void
+putch(int8 x, int8 y, int8 c)
+{
+        int16 *cons = (int16 *)0xb8000;
+        cons[y*80 + x] = 0x07 << 8 | c;
+}
+
+#pragma textflag NOSPLIT
+void
+runtime·doc(int64 mark)
+{
+        static int8 x;
+        static int8 y;
+
+        putch(x++, y, mark & 0xff);
+        //putch(x++, y, ' ');
+        if (x >= 79) {
+                x = 0;
+                y++;
+        }
+
+	if (y >= 29)
+		y = 0;
+}
+
+#pragma textflag NOSPLIT
+static void
+pnum(uint64 n)
+{
+	uint64 nn = (uint64)n;
+	int64 i;
+
+	for (i = 60; i >= 0; i -= 4) {
+		uint64 cn = (nn >> i) & 0xf;
+
+		if (cn >= 0 && cn <= 9)
+			runtime·doc('0' + cn);
+		else
+			runtime·doc('A' + cn - 10);
+	}
+}
+
+#pragma textflag NOSPLIT
+static void
+pmsg(int8 *msg)
+{
+	if (msg)
+		while (*msg)
+			runtime·doc(*msg++);
+}
+
+#pragma textflag NOSPLIT
+void
+runtime·pancake(int8 *msg, int64 addr)
+{
+	runtime·doc(' ');
+
+	pmsg(msg);
+
+	runtime·doc(' ');
+	pnum(addr);
+	pmsg(" PANCAKE");
+	while (1);
+}
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/os_linux_386.c
--- a/src/runtime/os_linux_386.c	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/os_linux_386.c	Tue Dec 02 21:38:36 2014 -0500
@@ -36,197 +36,3 @@
 		}
 	}
 }
-
-#pragma textflag NOSPLIT
-static void
-putch(int8 x, int8 y, int8 c)
-{
-        int16 *cons = (int16 *)0xb8000;
-        cons[y*80 + x] = 0x07 << 8 | c;
-}
-
-#pragma textflag NOSPLIT
-void
-runtime·doc(int64 mark)
-{
-        static int8 x;
-        static int8 y;
-
-        putch(x++, y, mark & 0xff);
-        //putch(x++, y, ' ');
-        if (x >= 79) {
-                x = 0;
-                y++;
-        }
-
-	if (y >= 29)
-		y = 0;
-}
-
-#pragma textflag NOSPLIT
-static void
-pnum(int64 n)
-{
-	int32 nn = (int32)n;
-	int32 i;
-
-	//for (i = 60; i >= 0; i -= 4) {
-	for (i = 28; i >= 0; i -= 4) {
-		int32 cn = (nn >> i) & 0xf;
-
-		if (cn >= 0 && cn <= 9)
-			runtime·doc('0' + cn);
-		else
-			runtime·doc('A' + cn - 10);
-	}
-}
-
-#pragma textflag NOSPLIT
-static void
-pmsg(int8 *msg)
-{
-	while (*msg)
-		runtime·doc(*msg++);
-}
-
-
-#pragma textflag NOSPLIT
-static void
-pancake(int8 *msg, int64 addr)
-{
-	runtime·doc(' ');
-
-	pmsg(msg);
-
-	runtime·doc(' ');
-	pnum(addr);
-	pmsg(" PANCAKE");
-	while (1);
-}
-
-#include "hackstuff.h"
-
-#pragma textflag NOSPLIT
-static uint32
-getpg(void)
-{
-	static uint32 last;
-
-	extern uint8 runtime·end[];
-	if (!last)
-		last = ROUNDUP((uint32)runtime·end, PGSIZE);
-
-	uint32 ret = last;
-	last += PGSIZE;
-
-	if (ret & PGOFFMASK)
-		pancake("not aligned", ret);
-
-	if (ret >= 0xc0000000 || ret < 0x01000000)
-		pancake("weird addr", ret);
-
-	int32 i;
-	for (i = 0; i < PGSIZE/4; i++)
-		((uint32 *)ret)[i] = 0;
-
-	return ret;
-}
-
-#pragma textflag NOSPLIT
-static void
-mapone(uint32 *pgd, uint32 va, uint32 pa)
-{
-	if (pa & PGOFFMASK)
-		pancake("pa not aligned", pa);
-
-	uint32 pde = pgd[PDX(va)];
-
-	if (!(pde & PTE_P)) {
-		pde = getpg() | PTE_P | PTE_W;
-		pgd[PDX(va)] = pde;
-	}
-
-	uint32 *pgt = (uint32 *)PTE_ADDR(pde);
-
-	if (pgt[PTX(va)] & PTE_P)
-		pancake("already mapped?", PTE_ADDR(pgt[PTX(va)]));
-
-	pgt[PTX(va)] = pa | PTE_P | PTE_W;
-}
-
-#pragma textflag NOSPLIT
-static void
-bootmap(uint32 *pgd, uint32 va, uint32 pa, uint32 sz)
-{
-	int32 i;
-	for (i = 0; i < sz; i += PGSIZE)
-		mapone(pgd, va + i, pa + i);
-}
-
-#pragma textflag NOSPLIT
-static void
-addsegs(struct Elf *e, uint32 *pgd)
-{
-	struct Proghdr *ph = (struct Proghdr *)((int8 *)e + e->e_phoff);
-	struct Proghdr *eph = ph + e->e_phnum;
-
-	for (; ph < eph; ph++) {
-		if (ph->p_type != 1) // PT_LOAD
-			continue;
-
-		bootmap(pgd, ph->p_pa, ph->p_pa, ph->p_memsz);
-	}
-}
-
-#pragma textflag NOSPLIT
-static void
-bsshack(void)
-{
-#define SAVE(x)	((uint32 *)(((uint32 *)0x7e00)[x]))
-	uint32 *start = SAVE(0);
-	uint32 *end = SAVE(1);
-#undef SAVE
-	while (start < end)
-		*start++ = 0;
-}
-
-extern uint32 *runtime·pgd;
-extern void runtime·lcr3(uint32);
-extern uint32 runtime·rcr3(void);
-extern void runtime·enable_paging(void);
-
-#pragma textflag NOSPLIT
-void
-runtime·pginit(void)
-{
-	int32 i;
-
-	// XXX the bootloader and this code assume there is at least ~130 MB of
-	// physical memory. should parse the e820 map.
-	bsshack();
-
-	runtime·pgd = (uint32 *)getpg();
-	if ((uint32)runtime·pgd & PGOFFMASK)
-		pancake("pgd not aligned?", (uint32)runtime·pgd);
-
-	for (i = 0; i < 1024; i++)
-		runtime·pgd[i] = 0;
-
-	// sweet hack -- header is still at physical address 0x10000
-	struct Elf *e = (struct Elf *)0x10000;
-	addsegs(e, runtime·pgd);
-	// give us VGA so we can print
-	mapone(runtime·pgd, 0xb8000, 0xb8000);
-	// and our stack
-	mapone(runtime·pgd, 0x7000, 0x7000);
-
-	runtime·lcr3((uint32)runtime·pgd);
-	pmsg("loaded cr3 ");
-	runtime·enable_paging();
-	pmsg("paging enabled ");
-	uint32 cr3 = runtime·rcr3();
-	pmsg("cr3 is ");
-	pnum(cr3);
-	//*(byte *)0 = 1;
-	//pmsg("wut");
-}
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/rt0_linux_386.s
--- a/src/runtime/rt0_linux_386.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/rt0_linux_386.s	Tue Dec 02 21:38:36 2014 -0500
@@ -12,7 +12,6 @@
 	CALL	runtime·linux_setup_vdso(SB)
 	CALL	main(SB)
 	INT	$3
-	CALL	_rt0_hack(SB)
 
 TEXT main(SB),NOSPLIT,$0
 	JMP	runtime·rt0_go(SB)
@@ -23,7 +22,3 @@
 
 DATA	runtime·_vdso(SB)/4, $_fallback_vdso(SB)
 GLOBL	runtime·_vdso(SB), NOPTR, $4
-
-TEXT _rt0_hack(SB),NOSPLIT,$0
-	CALL	runtime·rt0_go_hack(SB)
-	INT	$3
diff -r 7fbeea021a7d -r c2306e1c8f08 src/runtime/rt0_linux_amd64.s
--- a/src/runtime/rt0_linux_amd64.s	Mon Dec 01 19:25:36 2014 -0500
+++ b/src/runtime/rt0_linux_amd64.s	Tue Dec 02 21:38:36 2014 -0500
@@ -8,8 +8,14 @@
 	LEAQ	8(SP), SI // argv
 	MOVQ	0(SP), DI // argc
 	MOVQ	$main(SB), AX
-	JMP	AX
+	CALL	AX
+	CALL	_rt0_hack(SB)
+	INT	$3
 
 TEXT main(SB),NOSPLIT,$-8
 	MOVQ	$runtime·rt0_go(SB), AX
 	JMP	AX
+
+TEXT _rt0_hack(SB),NOSPLIT,$0
+	CALL	runtime·rt0_go_hack(SB)
+	INT	$3

changeset:   21876:3a1f8ad32b44
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Mon Dec 08 11:02:40 2014 -0500
summary:     checkpoint segmentation setup

diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/asm_amd64.s
--- a/src/runtime/asm_amd64.s	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/asm_amd64.s	Mon Dec 08 11:02:40 2014 -0500
@@ -119,10 +119,173 @@
 	// No per-thread init.
 	RET
 
+TEXT retardtown(SB),NOSPLIT,$0
+	MOVQ	(SP), AX
+	PUSHQ	$(3 << 3)
+	PUSHQ	AX
+	// lret
+	BYTE	$0xcb
+
 TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
-	//MOVL	$0x7c00, SP
 
-	//CALL	runtime·pginit(SB)
+//	CMPQ	DI, $0
+//	JEQ	duder
+//dud:
+//	JMP dud
+//duder:
+
+	// save page table and first free address from bootloader.
+	MOVL	DI, runtime·pgtbl(SB)
+	MOVL	SI, runtime·first_free(SB)
+
+	ANDQ	$~15, SP
+
+	// create istack out of the given (operating system) stack.
+	// _cgo_init may update stackguard.
+	MOVQ	$runtime·g0(SB), DI
+	LEAQ	(-64*1024+104)(SP), BX
+	MOVQ	BX, g_stackguard0(DI)
+	MOVQ	BX, g_stackguard1(DI)
+	MOVQ	BX, (g_stack+stack_lo)(DI)
+	MOVQ	SP, (g_stack+stack_hi)(DI)
+
+	// find out information about the processor we're on
+	MOVQ	$0, AX
+	CPUID
+	CMPQ	AX, $0
+	JE	h_nocpuinfo
+	MOVQ	$1, AX
+	CPUID
+	MOVL	CX, runtime·cpuid_ecx(SB)
+	MOVL	DX, runtime·cpuid_edx(SB)
+h_nocpuinfo:
+
+	PUSHQ	$0x20
+	CALL	runtime·doc(SB)
+	POPQ	AX
+
+	PUSHQ	$0x39
+	CALL	runtime·doc(SB)
+	CALL	runtime·doc(SB)
+	POPQ	AX
+
+	// if there is an _cgo_init, call it.
+	//MOVQ	_cgo_init(SB), AX
+	//TESTQ	AX, AX
+	//JZ	needtls
+	//// g0 already in DI
+	//MOVQ	DI, CX	// Win64 uses CX for first parameter
+	//MOVQ	$setg_gcc<>(SB), SI
+	//CALL	AX
+
+	//// update stackguard after _cgo_init
+	//MOVQ	$runtime·g0(SB), CX
+	//MOVQ	(g_stack+stack_lo)(CX), AX
+	//ADDQ	$const_StackGuard, AX
+	//MOVQ	AX, g_stackguard0(CX)
+	//MOVQ	AX, g_stackguard1(CX)
+
+	//CMPL	runtime·iswindows(SB), $0
+	//JEQ ok
+h_needtls:
+
+	//// skip TLS setup on Plan 9
+	//CMPL	runtime·isplan9(SB), $1
+	//JEQ ok
+	//// skip TLS setup on Solaris
+	//CMPL	runtime·issolaris(SB), $1
+	//JEQ ok
+
+//	CMPQ	AX, $0
+//	JEQ	duder
+//dud:
+//	JMP dud
+//duder:
+
+	// setup tls
+	LEAQ	runtime·tls0(SB), DI
+	PUSHQ	DI
+	CALL	runtime·segsetup(SB)
+
+	MOVQ	8(AX), DI
+	PUSHQ	DI
+	MOVQ	(AX), DI
+	PUSHQ	DI
+	// lgdt (%rsp)
+	BYTE	$0x0f
+	BYTE	$0x01
+	BYTE	$0x14
+	BYTE	$0x24
+	POPQ	AX
+	POPQ	AX
+
+	MOVQ	$(2 << 3), AX
+	PUSHQ	AX
+	POPQ	FS
+
+	//CALL retardtown(SB)
+
+	// store through it, to make sure it works
+	get_tls(BX)
+	MOVQ	$0x123, g(BX)
+	MOVQ	runtime·tls0(SB), AX
+	CMPQ	AX, $0x123
+	JEQ	h_ok
+	PUSHQ	$0xdeadbeed
+	PUSHQ	$0
+	CALL	runtime·pancake(SB)
+h_ok:
+	PUSHQ	$0x20
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0x31
+	CALL	runtime·doc(SB)
+	PUSHQ	$0xdeadbeef
+	PUSHQ	$0
+	CALL	runtime·pancake(SB)
+	INT	$3
+
+
+	// set the per-goroutine and per-mach "registers"
+	get_tls(BX)
+	LEAQ	runtime·g0(SB), CX
+	MOVQ	CX, g(BX)
+	LEAQ	runtime·m0(SB), AX
+
+	// save m->g0 = g0
+	MOVQ	CX, m_g0(AX)
+	// save m0 to g0->m
+	MOVQ	AX, g_m(CX)
+
+	CLD				// convention is D is always left cleared
+	CALL	runtime·check(SB)
+
+	MOVL	16(SP), AX		// copy argc
+	MOVL	AX, 0(SP)
+	MOVQ	24(SP), AX		// copy argv
+	MOVQ	AX, 8(SP)
+	CALL	runtime·args(SB)
+	CALL	runtime·osinit(SB)
+	CALL	runtime·schedinit(SB)
+
+	// create a new goroutine to start program
+	MOVQ	$runtime·main·f(SB), BP		// entry
+	PUSHQ	BP
+	PUSHQ	$0			// arg size
+	CALL	runtime·newproc(SB)
+	POPQ	AX
+	POPQ	AX
+
+	// start this M
+	CALL	runtime·mstart(SB)
+
+	MOVL	$0xf1, 0xf1  // crash
+	RET
 
 	PUSHQ	$0x20
 	CALL	runtime·doc(SB)
@@ -134,7 +297,7 @@
 	CALL	runtime·doc(SB)
 	PUSHQ	$0x31
 	CALL	runtime·doc(SB)
-	PUSHQ	$0xdeadbeef
+	PUSHQ	$0xc001d00d
 	PUSHQ	$0
 	CALL	runtime·pancake(SB)
 	INT	$3
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/os_linux.c	Mon Dec 08 11:02:40 2014 -0500
@@ -368,7 +368,7 @@
 }
 
 #pragma textflag NOSPLIT
-static void
+void
 pnum(uint64 n)
 {
 	uint64 nn = (uint64)n;
@@ -377,7 +377,7 @@
 	for (i = 60; i >= 0; i -= 4) {
 		uint64 cn = (nn >> i) & 0xf;
 
-		if (cn >= 0 && cn <= 9)
+		if (cn <= 9)
 			runtime·doc('0' + cn);
 		else
 			runtime·doc('A' + cn - 10);
@@ -395,7 +395,7 @@
 
 #pragma textflag NOSPLIT
 void
-runtime·pancake(int8 *msg, int64 addr)
+runtime·pancake(void *msg, int64 addr)
 {
 	runtime·doc(' ');
 
@@ -406,3 +406,166 @@
 	pmsg(" PANCAKE");
 	while (1);
 }
+
+// gee i wish i could pack structs with plan9 compiler
+struct pdesc_t {
+	uint8 dur[10];
+};
+
+struct seg64_t {
+	uint8 dur[8];
+	// 0,1 low limit
+	// 2,3 low base
+	// 4   mid base
+	// 5   p, dpl, s, type
+	// 6   g, d/b, l, avl, mid limit
+	// 7   high base
+};
+
+#define	G	0x80
+#define	D	0x40
+#define	L	0x20
+
+#define	CODE	0xa
+#define	DATA	0x2
+
+static struct seg64_t segs[4] = {
+	// NULL seg
+	{0, 0, 0, 0, 0, 0, 0, 0},
+
+	// data
+	{0xff, 0xff,	// limit
+	 0, 0, 0,	// base
+	 0x90 | DATA,	// p, dpl, s, type
+	 G | D | 0xf,	// g, d/b, l, avail, mid limit
+	 0},		// base high
+
+	// fs seg
+	{0xff, 0xff,	// limit
+	 0, 0, 0,	// base
+	 0x90 | DATA,	// p, dpl, s, type
+	 G | D | 0xf,	// g, d/b, l, avail, mid limit
+	 0},		// base high
+
+	// 64 bit code
+	{0xff, 0xff,	// limit
+	 0, 0, 0,	// base
+	 0x90 | CODE,	// p, dpl, s, type
+	 G | L | 0xf,	// g, d/b, l, avail, mid limit
+	 0},		// base high
+
+};
+
+static struct pdesc_t pd;
+
+#define	FS_SEG		2
+
+#pragma textflag NOSPLIT
+static void
+seg_set_base(struct seg64_t *seg, uint32 base, uint32 lim)
+{
+	uint8 b1 = base & 0xff;
+	uint8 b2 = (base >>  8) & 0xff;
+	uint8 b3 = (base >> 16) & 0xff;
+	uint8 b4 = (base >> 24) & 0xff;
+
+	uint8 l1 = lim & 0xff;
+	uint8 l2 = (lim >>  8) & 0xff;
+	uint8 l3 = (lim >> 16) & 0xff;
+
+	seg->dur[0] = l1;
+	seg->dur[1] = l2;
+	seg->dur[6] = l3 | G | D;
+
+	seg->dur[2] = b1;
+	seg->dur[3] = b2;
+	seg->dur[4] = b3;
+	seg->dur[7] = b4;
+}
+
+#undef DATA
+#undef CODE
+#undef G
+#undef D
+#undef L
+
+#define	CHECK32(x)	(x & ~((1ULL << 32) - 1))
+
+#pragma textflag NOSPLIT
+static void
+pdsetup(struct pdesc_t *pd, struct seg64_t *s, uint64 lim)
+{
+	uint64 addr = (uint64)s;
+
+	pd->dur[0] = lim & 0xff;
+	pd->dur[1] = (lim >> 8) & 0xff;
+
+	pd->dur[2] = addr & 0xff;
+	pd->dur[3] = (addr >>  8) & 0xff;
+	pd->dur[4] = (addr >> 16) & 0xff;
+	pd->dur[5] = (addr >> 24) & 0xff;
+	pd->dur[6] = (addr >> 32) & 0xff;
+	pd->dur[7] = (addr >> 40) & 0xff;
+	pd->dur[8] = (addr >> 48) & 0xff;
+	pd->dur[9] = (addr >> 56) & 0xff;
+}
+
+#pragma textflag NOSPLIT
+static void
+memcpy(void *dst, void *src, uint64 sz)
+{
+	uint8 *t = dst;
+	uint8 *f = src;
+
+	while (sz--)
+		*t++ = *f++;
+}
+
+struct pdesc_t duhee;
+
+#pragma textflag NOSPLIT
+uint64
+runtime·segsetup(void *tls0)
+{
+	uint64 tlsaddr = (uint64)tls0;
+
+	// TLS assembles to -16(%fs)
+	tlsaddr += 16;
+	pmsg("tls0 is ");
+	pnum(tlsaddr);
+
+	if (sizeof(struct pdesc_t) != 10)
+		runtime·pancake("pdesc not packed", sizeof(struct pdesc_t));
+
+	if (sizeof(struct seg64_t) != 8)
+		runtime·pancake("seg64 not packed", sizeof(struct seg64_t));
+	if (sizeof(struct seg64_t)*4 != 32)
+		runtime·pancake("wut?", sizeof(struct seg64_t)*4);
+
+	// gee i wish i could align data with plan9 compiler
+	if ((uint64)&pd & 0x7)
+		runtime·pancake("pdesc not aligned", (uint64)&pd);
+
+	if (CHECK32(tlsaddr))
+		runtime·pancake("tlsaddr > 32bits, use msrs", tlsaddr);
+
+	seg_set_base(&segs[FS_SEG], (uint32)tlsaddr, 0xffffffff);
+	//extern uint32 runtime·first_free;
+	//struct seg64_t *fleabag = (struct seg64_t *)runtime·first_free;
+	//memcpy(fleabag, segs, sizeof(segs));
+	//pdsetup(&pd, fleabag, sizeof(segs) - 1);
+	pdsetup(&pd, segs, sizeof(segs) - 1);
+
+	//{
+	//uint32 *p = (uint32 *)&segs[3];
+	//pmsg("stuff ");
+	//pnum(*p++);
+	//pmsg(" ");
+	//pnum(*p++);
+	//while(1);
+	//}
+
+	pmsg("set segs");
+
+	return (uint64)&pd;
+}
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/panic.go
--- a/src/runtime/panic.go	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/panic.go	Mon Dec 08 11:02:40 2014 -0500
@@ -482,6 +482,7 @@
 
 //go:nosplit
 func throw(s *byte) {
+	pancake(s, 0x31337)
 	gp := getg()
 	if gp.m.throwing == 0 {
 		gp.m.throwing = 1
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/proc.c
--- a/src/runtime/proc.c	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/proc.c	Mon Dec 08 11:02:40 2014 -0500
@@ -51,6 +51,10 @@
 uintptr runtime·allglen;
 ForceGCState	runtime·forcegc;
 
+// biscuit stuff
+int32 pgtbl;
+int32 first_free;
+
 void runtime·mstart(void);
 static void runqput(P*, G*);
 static G* runqget(P*);
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/rt0_linux_amd64.s
--- a/src/runtime/rt0_linux_amd64.s	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/rt0_linux_amd64.s	Mon Dec 08 11:02:40 2014 -0500
@@ -9,6 +9,7 @@
 	MOVQ	0(SP), DI // argc
 	MOVQ	$main(SB), AX
 	CALL	AX
+	MOVL	$1, 0	// abort
 	CALL	_rt0_hack(SB)
 	INT	$3
 
diff -r c2306e1c8f08 -r 3a1f8ad32b44 src/runtime/stubs.go
--- a/src/runtime/stubs.go	Tue Dec 02 21:38:36 2014 -0500
+++ b/src/runtime/stubs.go	Mon Dec 08 11:02:40 2014 -0500
@@ -122,6 +122,8 @@
 func readmemstats_m()
 func writeheapdump_m()
 
+func pancake(*byte, int)
+
 // memclr clears n bytes starting at ptr.
 // in memclr_*.s
 //go:noescape

changeset:   21877:0a7171e4df71
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Mon Dec 08 15:45:49 2014 -0500
summary:     finish segmentation

diff -r 3a1f8ad32b44 -r 0a7171e4df71 src/runtime/asm_amd64.s
--- a/src/runtime/asm_amd64.s	Mon Dec 08 11:02:40 2014 -0500
+++ b/src/runtime/asm_amd64.s	Mon Dec 08 15:45:49 2014 -0500
@@ -119,21 +119,25 @@
 	// No per-thread init.
 	RET
 
-TEXT retardtown(SB),NOSPLIT,$0
-	MOVQ	(SP), AX
+TEXT fixcs(SB),NOSPLIT,$0
+	POPQ	AX
 	PUSHQ	$(3 << 3)
 	PUSHQ	AX
-	// lret
+	// lretq
+	BYTE	$0x48
 	BYTE	$0xcb
+	MOVQ	$1, 0
+	//POPQ	DX
+	//MOVQ	$(3 << 3), AX
+	//SHLQ	$32, AX
+	//ORQ	DX, AX
+	//PUSHQ	AX
+	//// lret
+	//BYTE	$0xcb
+	//MOVQ	$1, 0
 
 TEXT runtime·rt0_go_hack(SB),NOSPLIT,$0
 
-//	CMPQ	DI, $0
-//	JEQ	duder
-//dud:
-//	JMP dud
-//duder:
-
 	// save page table and first free address from bootloader.
 	MOVL	DI, runtime·pgtbl(SB)
 	MOVL	SI, runtime·first_free(SB)
@@ -196,12 +200,6 @@
 	//CMPL	runtime·issolaris(SB), $1
 	//JEQ ok
 
-//	CMPQ	AX, $0
-//	JEQ	duder
-//dud:
-//	JMP dud
-//duder:
-
 	// setup tls
 	LEAQ	runtime·tls0(SB), DI
 	PUSHQ	DI
@@ -218,12 +216,24 @@
 	BYTE	$0x24
 	POPQ	AX
 	POPQ	AX
+	POPQ	AX
 
 	MOVQ	$(2 << 3), AX
 	PUSHQ	AX
 	POPQ	FS
 
-	//CALL retardtown(SB)
+	MOVL	$(1 << 3), AX
+	//MOVL	AX, ES
+	BYTE	$0x8e
+	BYTE	$0xd8
+	//MOVL	AX, DS
+	BYTE	$0x8e
+	BYTE	$0xc0
+	//MOVL	AX, SS
+	BYTE	$0x8e
+	BYTE	$0xd0
+
+	CALL fixcs(SB)
 
 	// store through it, to make sure it works
 	get_tls(BX)
@@ -231,22 +241,16 @@
 	MOVQ	runtime·tls0(SB), AX
 	CMPQ	AX, $0x123
 	JEQ	h_ok
-	PUSHQ	$0xdeadbeed
+	MOVQ	$0x4242424242424242, AX
+	PUSHQ	AX
 	PUSHQ	$0
 	CALL	runtime·pancake(SB)
+
 h_ok:
-	PUSHQ	$0x20
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0x31
-	CALL	runtime·doc(SB)
-	PUSHQ	$0xdeadbeef
-	PUSHQ	$0
+	MOVQ	$0xc001d00ddeadbeef, AX
+	PUSHQ	AX
+	MOVQ	$runtime·madeit(SB), AX
+	PUSHQ	AX
 	CALL	runtime·pancake(SB)
 	INT	$3
 
diff -r 3a1f8ad32b44 -r 0a7171e4df71 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Mon Dec 08 11:02:40 2014 -0500
+++ b/src/runtime/os_linux.c	Mon Dec 08 15:45:49 2014 -0500
@@ -393,6 +393,8 @@
 			runtime·doc(*msg++);
 }
 
+uint8 runtime·madeit[] = "We made it!";
+
 #pragma textflag NOSPLIT
 void
 runtime·pancake(void *msg, int64 addr)
@@ -414,12 +416,6 @@
 
 struct seg64_t {
 	uint8 dur[8];
-	// 0,1 low limit
-	// 2,3 low base
-	// 4   mid base
-	// 5   p, dpl, s, type
-	// 6   g, d/b, l, avl, mid limit
-	// 7   high base
 };
 
 #define	G	0x80
@@ -453,7 +449,6 @@
 	 0x90 | CODE,	// p, dpl, s, type
 	 G | L | 0xf,	// g, d/b, l, avail, mid limit
 	 0},		// base high
-
 };
 
 static struct pdesc_t pd;
@@ -511,19 +506,6 @@
 }
 
 #pragma textflag NOSPLIT
-static void
-memcpy(void *dst, void *src, uint64 sz)
-{
-	uint8 *t = dst;
-	uint8 *f = src;
-
-	while (sz--)
-		*t++ = *f++;
-}
-
-struct pdesc_t duhee;
-
-#pragma textflag NOSPLIT
 uint64
 runtime·segsetup(void *tls0)
 {
@@ -531,8 +513,6 @@
 
 	// TLS assembles to -16(%fs)
 	tlsaddr += 16;
-	pmsg("tls0 is ");
-	pnum(tlsaddr);
 
 	if (sizeof(struct pdesc_t) != 10)
 		runtime·pancake("pdesc not packed", sizeof(struct pdesc_t));
@@ -549,23 +529,8 @@
 	if (CHECK32(tlsaddr))
 		runtime·pancake("tlsaddr > 32bits, use msrs", tlsaddr);
 
-	seg_set_base(&segs[FS_SEG], (uint32)tlsaddr, 0xffffffff);
-	//extern uint32 runtime·first_free;
-	//struct seg64_t *fleabag = (struct seg64_t *)runtime·first_free;
-	//memcpy(fleabag, segs, sizeof(segs));
-	//pdsetup(&pd, fleabag, sizeof(segs) - 1);
+	seg_set_base(&segs[FS_SEG], (uint32)tlsaddr, 15);
 	pdsetup(&pd, segs, sizeof(segs) - 1);
 
-	//{
-	//uint32 *p = (uint32 *)&segs[3];
-	//pmsg("stuff ");
-	//pnum(*p++);
-	//pmsg(" ");
-	//pnum(*p++);
-	//while(1);
-	//}
-
-	pmsg("set segs");
-
 	return (uint64)&pd;
 }

changeset:   21878:f2eefaeb0220
tag:         tip
user:        Cody Cutler <ccutler@csail.mit.edu>
date:        Mon Dec 08 16:02:07 2014 -0500
summary:     x

diff -r 0a7171e4df71 -r f2eefaeb0220 src/runtime/os_linux.c
--- a/src/runtime/os_linux.c	Mon Dec 08 15:45:49 2014 -0500
+++ b/src/runtime/os_linux.c	Mon Dec 08 16:02:07 2014 -0500
@@ -429,25 +429,27 @@
 	// NULL seg
 	{0, 0, 0, 0, 0, 0, 0, 0},
 
+	// limits and base are ignored (except for fs/gs) in long mode.
+
 	// data
-	{0xff, 0xff,	// limit
+	{0, 0,		// limit
 	 0, 0, 0,	// base
 	 0x90 | DATA,	// p, dpl, s, type
-	 G | D | 0xf,	// g, d/b, l, avail, mid limit
+	 G | D,	// g, d/b, l, avail, mid limit
 	 0},		// base high
 
 	// fs seg
-	{0xff, 0xff,	// limit
+	{0, 0,		// limit
 	 0, 0, 0,	// base
 	 0x90 | DATA,	// p, dpl, s, type
-	 G | D | 0xf,	// g, d/b, l, avail, mid limit
+	 G | D | 0,	// g, d/b, l, avail, mid limit
 	 0},		// base high
 
 	// 64 bit code
-	{0xff, 0xff,	// limit
+	{0, 0,		// limit
 	 0, 0, 0,	// base
 	 0x90 | CODE,	// p, dpl, s, type
-	 G | L | 0xf,	// g, d/b, l, avail, mid limit
+	 G | L | 0,	// g, d/b, l, avail, mid limit
 	 0},		// base high
 };
 

