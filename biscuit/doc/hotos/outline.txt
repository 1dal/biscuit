Title: revisiting writing kernels in type-safe languages (again)

Kernels have been written in type-safe, garbage-collected languages (Unikernel,
Singularity, SPIN, Taos, etc.), but it is still not common practice.

We are argue it is time to revisit using type-safe languages for writing kernels for several reasons:

1. Kernels must be more parallel to exploit the increasing number of cores,
which is easier in a language with good support for expressing parallelism.
Because C/C++ offer little support for fine-grained parallelism, the typical
organization of a kernel is to have a number of threads that equals the number
of cores. Languages such as Go offer lightweight threads and encourage the
programmer to create many threads. Applying this approach to designing a kernel
results in a different organization than today's kernels. This approach also
requires automatic memory management, because manual reference counting with
lots of small threads operating on shared data structures is challenging.

2. The emergence of new type-safe languages that are designed for systems
programming (i.e., Go and Rust). These languages are likely to be a better match
for writing kernels than previous type-safe languages. The usages of Go and Rust
has focussed on browsers and servers, which share similarities with kernel
programming. In fact, an OS class at UVA asks students to write a tiny kernel in
Rust~\cite{uva:os}. We propose to write a more functional kernel in a fat kernel
style, which provides more room for a type-safe language to shine. Many of the
previous kernels written in type-safe languages are microkernels (e.g.,
Singularity, SPIN, Taos, etc.), which have little functionality and code, and
thus little opportunity to demonstrate the value of a type-safe language.
Furthermore, if the language enforces isolation through the type system, then
there is less reason to write kernel in a microkernel style. (XXX maybe say
something about proof-carrying code and extensibility.)

3. Understanding the impact of automatic memory management in a kernel setting.
Rust and Go take a different approach to memory management. Rust puts the burden
on the programmer while Go takes the traditional approach of putting the burden
on the garbage collector. What is the right choice? Anecdotal evidence suggests
that automatic garbage collection can be a problem in a kernel (cite private
conversations w. Hunt) and it is often a challenge in writing high-performance
servers, which argues for the Rust approach. On the other hand, if kernel uses
lots of fine-grained parallelism, automatic garbage collection is more
desirable. Furthermore, kernels are often more stylized and maybe with a more
kernel-aware garbage collector, automatic garbage collection will work fine.
(XXX maybe phrase this more as linear types versus general-purpose GC, brings in
Singularity too.)

Potential outline (maybe more for SOSP?):

1. Intro (articulating the above points better)

2. Design (parallelism, interfaces, extensibility, GC)

3. Impl (what it takes to use Go to implement design)

4. Eval (focussing on parallelism and GC?)

Another outline for hotos which explores the 3 reasons in more depth by
argument (instead of design/impl/eval):

1. Intro (articulating the above points better)

2. Why lots of parallelism and how it leads to a different kernel design

3. Why look at fat kernels

4. Linear types versus general-purpose GC


